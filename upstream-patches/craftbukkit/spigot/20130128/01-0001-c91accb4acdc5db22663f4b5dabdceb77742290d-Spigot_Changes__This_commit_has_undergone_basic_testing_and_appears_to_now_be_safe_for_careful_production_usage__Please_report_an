From c91accb4acdc5db22663f4b5dabdceb77742290d Mon Sep 17 00:00:00 2001
From: md_5 <md_5@bigpond.com>
Date: Sun, 30 Dec 2012 23:56:05 -0600
Subject: [PATCH] Spigot Changes. This commit has undergone basic testing and appears to now be safe for careful production usage. Please report any bugs to IRC as soon as you encounter them. Long live Spigot!


diff --git a/.gitignore b/.gitignore
index a689360..4138573 100644
--- a/.gitignore
+++ b/.gitignore
@@ -34,3 +34,5 @@
 
 /src/main/resources/achievement
 /src/main/resources/lang
+
+/dependency-reduced-pom.xml
diff --git a/pom.xml b/pom.xml
index aa4ac8b..d768e81 100644
--- a/pom.xml
+++ b/pom.xml
@@ -51,8 +51,8 @@
 
   <dependencies>
     <dependency>
-      <groupId>org.bukkit</groupId>
-      <artifactId>bukkit</artifactId>
+      <groupId>org.spigotmc</groupId>
+      <artifactId>spigot-api</artifactId>
       <version>${project.version}</version>
       <type>jar</type>
       <scope>compile</scope>
@@ -156,6 +156,11 @@
       <version>1.3</version>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>net.sf.trove4j</groupId>
+      <artifactId>trove4j</artifactId>
+      <version>3.0.2</version>
+    </dependency>
   </dependencies>
 
   <!-- This builds a completely 'ready to start' jar with all dependencies inside -->
@@ -167,7 +172,7 @@
         <artifactId>gitdescribe-maven-plugin</artifactId>
         <version>1.3</version>
         <configuration>
-          <outputPrefix>git-Bukkit-</outputPrefix>
+          <outputPrefix>git-Spigot-</outputPrefix>
           <outputPostfix></outputPostfix>
         </configuration>
         <executions>
diff --git a/src/minecraft/net/minecraft/block/Block.java b/src/minecraft/net/minecraft/block/Block.java
index a495d1d..9397cab 100644
--- a/src/minecraft/net/minecraft/block/Block.java
+++ b/src/minecraft/net/minecraft/block/Block.java
@@ -1247,4 +1247,21 @@ public class Block
         return 0;
     }
     // CraftBukkit end
+
+    // Spigot start
+    public static float range(float min, float value, float max)
+    {
+        if (value < min)
+        {
+            return min;
+        }
+
+        if (value > max)
+        {
+            return max;
+        }
+
+        return value;
+    }
+    // Spigot end
 }
diff --git a/src/minecraft/net/minecraft/block/BlockCactus.java b/src/minecraft/net/minecraft/block/BlockCactus.java
index b2629fb..e8a1799 100644
--- a/src/minecraft/net/minecraft/block/BlockCactus.java
+++ b/src/minecraft/net/minecraft/block/BlockCactus.java
@@ -38,7 +38,7 @@ public class BlockCactus extends Block
             {
                 int var7 = par1World.getBlockMetadata(par2, par3, par4);
 
-                if (var7 == 15)
+                if (var7 >= (byte) range(3, (par1World.growthOdds * 100 / par1World.getWorld().cactusGrowthModifier * 15 / 100F) + 0.5F, 15))   // Spigot
                 {
                     org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockGrowEvent(par1World, par2, par3 + 1, par4, this.blockID, 0); // CraftBukkit
                     par1World.setBlockMetadataWithNotify(par2, par3, par4, 0);
diff --git a/src/minecraft/net/minecraft/block/BlockCrops.java b/src/minecraft/net/minecraft/block/BlockCrops.java
index e9dac8a..409d7b5 100644
--- a/src/minecraft/net/minecraft/block/BlockCrops.java
+++ b/src/minecraft/net/minecraft/block/BlockCrops.java
@@ -46,7 +46,7 @@ public class BlockCrops extends BlockFlower
             {
                 float var7 = this.getGrowthRate(par1World, par2, par3, par4);
 
-                if (par5Random.nextInt((int)(25.0F / var7) + 1) == 0)
+                if (par5Random.nextInt((int)((par1World.growthOdds * 100 / par1World.getWorld().wheatGrowthModifier / 25.0F) / var7) + 1) == 0)    // Spigot
                 {
                     org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockGrowEvent(par1World, par2, par3, par4, this.blockID, ++var6); // CraftBukkit
                 }
diff --git a/src/minecraft/net/minecraft/block/BlockGrass.java b/src/minecraft/net/minecraft/block/BlockGrass.java
index ef2a17a..7509d38 100644
--- a/src/minecraft/net/minecraft/block/BlockGrass.java
+++ b/src/minecraft/net/minecraft/block/BlockGrass.java
@@ -54,7 +54,7 @@ public class BlockGrass extends Block
             }
             else if (par1World.getBlockLightValue(par2, par3 + 1, par4) >= 9)
             {
-                for (int var6 = 0; var6 < 4; ++var6)
+                for (int var6 = 0; var6 < Math.max(4, Math.max(20, (int)(4 * 100F / par1World.growthOdds))); ++var6)    // Spigot
                 {
                     int var7 = par2 + par5Random.nextInt(3) - 1;
                     int var8 = par3 + par5Random.nextInt(5) - 3;
diff --git a/src/minecraft/net/minecraft/block/BlockMushroom.java b/src/minecraft/net/minecraft/block/BlockMushroom.java
index 86599ed..0fb85c4 100644
--- a/src/minecraft/net/minecraft/block/BlockMushroom.java
+++ b/src/minecraft/net/minecraft/block/BlockMushroom.java
@@ -30,7 +30,7 @@ public class BlockMushroom extends BlockFlower
      */
     public void updateTick(World par1World, int par2, int par3, int par4, Random par5Random)
     {
-        if (par5Random.nextInt(25) == 0)
+        if (par5Random.nextInt((int)(par1World.growthOdds * 100 / par1World.getWorld().mushroomGrowthModifier * 25)) == 0)    // Spigot
         {
             byte var6 = 4;
             int var7 = 5;
diff --git a/src/minecraft/net/minecraft/block/BlockMycelium.java b/src/minecraft/net/minecraft/block/BlockMycelium.java
index 7080956..a4eabbc 100644
--- a/src/minecraft/net/minecraft/block/BlockMycelium.java
+++ b/src/minecraft/net/minecraft/block/BlockMycelium.java
@@ -54,7 +54,7 @@ public class BlockMycelium extends Block
             }
             else if (par1World.getBlockLightValue(par2, par3 + 1, par4) >= 9)
             {
-                for (int var6 = 0; var6 < 4; ++var6)
+                for (int var6 = 0; var6 < Math.max(4, Math.max(20, (int)(4 * 100F / par1World.growthOdds))); ++var6)    // Spigot
                 {
                     int var7 = par2 + par5Random.nextInt(3) - 1;
                     int var8 = par3 + par5Random.nextInt(5) - 3;
diff --git a/src/minecraft/net/minecraft/block/BlockReed.java b/src/minecraft/net/minecraft/block/BlockReed.java
index 10302e5..827355f 100644
--- a/src/minecraft/net/minecraft/block/BlockReed.java
+++ b/src/minecraft/net/minecraft/block/BlockReed.java
@@ -35,7 +35,7 @@ public class BlockReed extends Block
             {
                 int var7 = par1World.getBlockMetadata(par2, par3, par4);
 
-                if (var7 == 15)
+                if (var7 >= (byte) range(3, (par1World.growthOdds * 100 / par1World.getWorld().sugarGrowthModifier * 15 / 100F) + 0.5F, 15))   // Spigot
                 {
                     org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockGrowEvent(par1World, par2, par3 + 1, par4, this.blockID, 0); // CraftBukkit
                     par1World.setBlockMetadataWithNotify(par2, par3, par4, 0);
diff --git a/src/minecraft/net/minecraft/block/BlockSapling.java b/src/minecraft/net/minecraft/block/BlockSapling.java
index ce2338a..3410c0a 100644
--- a/src/minecraft/net/minecraft/block/BlockSapling.java
+++ b/src/minecraft/net/minecraft/block/BlockSapling.java
@@ -43,7 +43,7 @@ public class BlockSapling extends BlockFlower
             {
                 int var6 = par1World.getBlockMetadata(par2, par3, par4);
 
-                if ((var6 & 8) == 0)
+                if (par1World.getBlockLightValue(par2, par3 + 1, par4) >= 9 && (par5Random.nextInt(Math.max(2, (int)((par1World.growthOdds * 100 / par1World.getWorld().treeGrowthModifier * 7 / 100F) + 0.5F))) == 0))    // Spigot
                 {
                     par1World.setBlockMetadataWithNotify(par2, par3, par4, var6 | 8);
                 }
diff --git a/src/minecraft/net/minecraft/block/BlockStem.java b/src/minecraft/net/minecraft/block/BlockStem.java
index 633c2bd..4dce703 100644
--- a/src/minecraft/net/minecraft/block/BlockStem.java
+++ b/src/minecraft/net/minecraft/block/BlockStem.java
@@ -44,7 +44,7 @@ public class BlockStem extends BlockFlower
         {
             float var6 = this.getGrowthModifier(par1World, par2, par3, par4);
 
-            if (par5Random.nextInt((int)(25.0F / var6) + 1) == 0)
+            if (par5Random.nextInt((int)((par1World.growthOdds * 100 / ((this.blockID == Block.pumpkinStem.blockID) ? par1World.getWorld().pumpkinGrowthModifier : par1World.getWorld().melonGrowthModifier) / 25.0F) / var6) + 1) == 0)    // Spigot
             {
                 int var7 = par1World.getBlockMetadata(par2, par3, par4);
 
diff --git a/src/minecraft/net/minecraft/entity/EntityTrackerEntry.java b/src/minecraft/net/minecraft/entity/EntityTrackerEntry.java
index fe89358..cd92f85 100644
--- a/src/minecraft/net/minecraft/entity/EntityTrackerEntry.java
+++ b/src/minecraft/net/minecraft/entity/EntityTrackerEntry.java
@@ -154,6 +154,12 @@ public class EntityTrackerEntry
                 {
                     EntityPlayer var30 = (EntityPlayer)var29.next();
                     EntityPlayerMP var31 = (EntityPlayerMP)var30;
+
+                    if (var31.sentFrames.contains(var23.uniqueId))
+                    {
+                        continue;    // Spigot
+                    }
+
                     var26.updateVisiblePlayers(var31, var24);
 
                     if (var31.playerNetServerHandler.packetSize() <= 5)
@@ -163,6 +169,7 @@ public class EntityTrackerEntry
                         if (var32 != null)
                         {
                             var31.playerNetServerHandler.sendPacketToPlayer(var32);
+                            var31.sentFrames.add(var23.uniqueId); // Spigot
                         }
                     }
                 }
diff --git a/src/minecraft/net/minecraft/entity/item/EntityItem.java b/src/minecraft/net/minecraft/entity/item/EntityItem.java
index 250983f..a9dec5e 100644
--- a/src/minecraft/net/minecraft/entity/item/EntityItem.java
+++ b/src/minecraft/net/minecraft/entity/item/EntityItem.java
@@ -96,51 +96,55 @@ public class EntityItem extends Entity
         this.delayBeforeCanPickup -= (currentTick - this.lastTick);
         this.lastTick = currentTick;
         // CraftBukkit end
-        this.prevPosX = this.posX;
-        this.prevPosY = this.posY;
-        this.prevPosZ = this.posZ;
-        this.motionY -= 0.03999999910593033D;
-        this.noClip = this.pushOutOfBlocks(this.posX, (this.boundingBox.minY + this.boundingBox.maxY) / 2.0D, this.posZ);
-        this.moveEntity(this.motionX, this.motionY, this.motionZ);
-        boolean var1 = (int)this.prevPosX != (int)this.posX || (int)this.prevPosY != (int)this.posY || (int)this.prevPosZ != (int)this.posZ;
-
-        if (var1 || this.ticksExisted % 25 == 0)
+
+        if (lastTick % 2 == 0)   // Spigot
         {
-            if (this.worldObj.getBlockMaterial(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY), MathHelper.floor_double(this.posZ)) == Material.lava)
+            this.prevPosX = this.posX;
+            this.prevPosY = this.posY;
+            this.prevPosZ = this.posZ;
+            this.motionY -= 0.03999999910593033D;
+            this.noClip = this.pushOutOfBlocks(this.posX, (this.boundingBox.minY + this.boundingBox.maxY) / 2.0D, this.posZ);
+            this.moveEntity(this.motionX, this.motionY, this.motionZ);
+            boolean var1 = (int) this.prevPosX != (int) this.posX || (int) this.prevPosY != (int) this.posY || (int) this.prevPosZ != (int) this.posZ;
+
+            if (var1 || this.ticksExisted % 25 == 0)
             {
-                this.motionY = 0.20000000298023224D;
-                this.motionX = (double)((this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F);
-                this.motionZ = (double)((this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F);
-                this.playSound("random.fizz", 0.4F, 2.0F + this.rand.nextFloat() * 0.4F);
-            }
+                if (this.worldObj.getBlockMaterial(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.posY), MathHelper.floor_double(this.posZ)) == Material.lava)
+                {
+                    this.motionY = 0.20000000298023224D;
+                    this.motionX = (double)((this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F);
+                    this.motionZ = (double)((this.rand.nextFloat() - this.rand.nextFloat()) * 0.2F);
+                    this.playSound("random.fizz", 0.4F, 2.0F + this.rand.nextFloat() * 0.4F);
+                }
 
-            if (!this.worldObj.isRemote)
-            {
-                this.func_85054_d();
+                if (!this.worldObj.isRemote)
+                {
+                    this.func_85054_d();
+                }
             }
-        }
-
-        float var2 = 0.98F;
 
-        if (this.onGround)
-        {
-            var2 = 0.58800006F;
-            int var3 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.boundingBox.minY) - 1, MathHelper.floor_double(this.posZ));
+            float var2 = 0.98F;
 
-            if (var3 > 0)
+            if (this.onGround)
             {
-                var2 = Block.blocksList[var3].slipperiness * 0.98F;
+                var2 = 0.58800006F;
+                int var3 = this.worldObj.getBlockId(MathHelper.floor_double(this.posX), MathHelper.floor_double(this.boundingBox.minY) - 1, MathHelper.floor_double(this.posZ));
+
+                if (var3 > 0)
+                {
+                    var2 = Block.blocksList[var3].slipperiness * 0.98F;
+                }
             }
-        }
 
-        this.motionX *= (double)var2;
-        this.motionY *= 0.9800000190734863D;
-        this.motionZ *= (double)var2;
+            this.motionX *= (double) var2;
+            this.motionY *= 0.9800000190734863D;
+            this.motionZ *= (double) var2;
 
-        if (this.onGround)
-        {
-            this.motionY *= -0.5D;
-        }
+            if (this.onGround)
+            {
+                this.motionY *= -0.5D;
+            }
+        } // Spigot
 
         ++this.age;
 
diff --git a/src/minecraft/net/minecraft/entity/passive/EntitySquid.java b/src/minecraft/net/minecraft/entity/passive/EntitySquid.java
index 42b1f36..d958fb3 100644
--- a/src/minecraft/net/minecraft/entity/passive/EntitySquid.java
+++ b/src/minecraft/net/minecraft/entity/passive/EntitySquid.java
@@ -1,8 +1,6 @@
 package net.minecraft.entity.passive;
 
 import org.bukkit.craftbukkit.TrigMath; // CraftBukkit
-import net.minecraft.block.material.Material;
-import net.minecraft.entity.Entity;
 import net.minecraft.util.MathHelper;
 import net.minecraft.world.World;
 
@@ -100,15 +98,6 @@ public class EntitySquid extends EntityWaterMob
     }
 
     /**
-     * Checks if this entity is inside water (if inWater field is true as a result of handleWaterMovement() returning
-     * true)
-     */
-    public boolean isInWater()
-    {
-        return this.worldObj.handleMaterialAcceleration(this.boundingBox.expand(0.0D, -0.6000000238418579D, 0.0D), Material.water, (Entity) this);
-    }
-
-    /**
      * Called frequently so the entity can update its state every tick as required. For example, zombies and skeletons
      * use this to react to sunlight and start to burn.
      */
diff --git a/src/minecraft/net/minecraft/entity/player/EntityPlayerMP.java b/src/minecraft/net/minecraft/entity/player/EntityPlayerMP.java
index f3f23e1..9ae28c6 100644
--- a/src/minecraft/net/minecraft/entity/player/EntityPlayerMP.java
+++ b/src/minecraft/net/minecraft/entity/player/EntityPlayerMP.java
@@ -154,6 +154,7 @@ public class EntityPlayerMP extends EntityPlayer implements ICrafting
     public int newTotalExp = 0;
     public boolean keepLevel = false;
     // CraftBukkit end
+    public java.util.Set<java.util.UUID> sentFrames = new java.util.HashSet<java.util.UUID>(); // Spigot
 
     public EntityPlayerMP(MinecraftServer par1MinecraftServer, World par2World, String par3Str, ItemInWorldManager par4ItemInWorldManager)
     {
diff --git a/src/minecraft/net/minecraft/network/NetServerHandler.java b/src/minecraft/net/minecraft/network/NetServerHandler.java
index a955908..8f79e6f 100644
--- a/src/minecraft/net/minecraft/network/NetServerHandler.java
+++ b/src/minecraft/net/minecraft/network/NetServerHandler.java
@@ -1136,10 +1136,25 @@ public class NetServerHandler extends NetHandler
                 }
 
                 this.chat(var2, par1Packet3Chat.canProcessAsync());
+                // Spigot start
+                boolean isCounted = true;
+
+                if (server.spamGuardExclusions != null)
+                {
+                    for (String excluded : server.spamGuardExclusions)
+                    {
+                        if (var2.startsWith(excluded))
+                        {
+                            isCounted = false;
+                            break;
+                        }
+                    }
+                }
 
                 // This section stays because it is only applicable to packets
-                if (chatSpamField.addAndGet(this, 20) > 200 && !this.mcServer.getConfigurationManager().areCommandsAllowed(this.playerEntity.username))   // CraftBukkit use thread-safe spam
+                if (isCounted && chatSpamField.addAndGet(this, 20) > 200 && !this.mcServer.getConfigurationManager().areCommandsAllowed(this.playerEntity.username))   // CraftBukkit use thread-safe spam
                 {
+                    // Spigot end
                     // CraftBukkit start
                     if (par1Packet3Chat.canProcessAsync())
                     {
@@ -1315,7 +1330,10 @@ public class NetServerHandler extends NetHandler
 
         try
         {
-            logger.info(event.getPlayer().getName() + " issued server command: " + event.getMessage()); // CraftBukkit
+            if (server.logCommands)
+            {
+                logger.info(event.getPlayer().getName() + " issued server command: " + event.getMessage());    // Spigot
+            }
 
             if (this.server.dispatchCommand(event.getPlayer(), event.getMessage().substring(1)))
             {
@@ -1854,9 +1872,10 @@ public class NetServerHandler extends NetHandler
                 {
                     for (var6 = 0; var6 < par1Packet130UpdateSign.signLines[var8].length(); ++var6)
                     {
-                        if (ChatAllowedCharacters.allowedCharacters.indexOf(par1Packet130UpdateSign.signLines[var8].charAt(var6)) < 0)
+                        if (!ChatAllowedCharacters.isAllowedCharacter(par1Packet130UpdateSign.signLines[var8].charAt(var6)))
                         {
                             var5 = false;
+                            break;
                         }
                     }
                 }
diff --git a/src/minecraft/net/minecraft/network/ThreadLoginVerifier.java b/src/minecraft/net/minecraft/network/ThreadLoginVerifier.java
index 56695cb..6002836 100644
--- a/src/minecraft/net/minecraft/network/ThreadLoginVerifier.java
+++ b/src/minecraft/net/minecraft/network/ThreadLoginVerifier.java
@@ -5,6 +5,7 @@ import java.io.InputStreamReader;
 import java.math.BigInteger;
 import java.net.URL;
 import java.net.URLEncoder;
+import net.minecraft.network.packet.Packet255KickDisconnect;
 import net.minecraft.util.CryptManager;
 
 // CraftBukkit start
@@ -33,6 +34,40 @@ class ThreadLoginVerifier extends Thread
     {
         try
         {
+            // Spigot start
+            if (((CraftServer) org.bukkit.Bukkit.getServer()).ipFilter)
+            {
+                try
+                {
+                    String ip = this.loginHandler.getSocket().getInetAddress().getHostAddress();
+                    String[] split = ip.split("\\.");
+                    StringBuilder lookup = new StringBuilder();
+
+                    for (int i = split.length - 1; i >= 0; i--)
+                    {
+                        lookup.append(split[i]);
+                        lookup.append(".");
+                    }
+
+                    if (!ip.contains("127.0.0.1"))
+                    {
+                        lookup.append("xbl.spamhaus.org.");
+
+                        if (java.net.InetAddress.getByName(lookup.toString()) != null)
+                        {
+                            this.loginHandler.myTCPConnection.addToSendQueue(new Packet255KickDisconnect("Your IP address (" + ip + ") is flagged as unsafe by spamhaus.org/xbl"));
+                            this.loginHandler.myTCPConnection.serverShutdown();
+                            this.loginHandler.connectionComplete = true;
+                            return;
+                        }
+                    }
+                }
+                catch (Exception ex)
+                {
+                }
+            }
+
+            // Spigot end
             String var1 = (new BigInteger(CryptManager.getServerIdHash(NetLoginHandler.getServerId(this.loginHandler), NetLoginHandler.getLoginMinecraftServer(this.loginHandler).getKeyPair().getPublic(), NetLoginHandler.getSharedKey(this.loginHandler)))).toString(16);
             URL var2 = new URL("http://session.minecraft.net/game/checkserver.jsp?user=" + URLEncoder.encode(NetLoginHandler.getClientUsername(this.loginHandler), "UTF-8") + "&serverId=" + URLEncoder.encode(var1, "UTF-8"));
             BufferedReader var3 = new BufferedReader(new InputStreamReader(var2.openStream()));
diff --git a/src/minecraft/net/minecraft/server/MinecraftServer.java b/src/minecraft/net/minecraft/server/MinecraftServer.java
index f5def75..e4796b9 100644
--- a/src/minecraft/net/minecraft/server/MinecraftServer.java
+++ b/src/minecraft/net/minecraft/server/MinecraftServer.java
@@ -190,6 +190,11 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IPlay
     public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
     public int autosavePeriod;
     // CraftBukkit end
+    // Spigot start
+    private static final int TPS = 20;
+    private static final int TICK_TIME = 1000000000 / TPS;
+    public static double currentTPS = 0;
+    // Spigot end
 
     public MinecraftServer(OptionSet options)   // CraftBukkit - signature file -> OptionSet
     {
@@ -592,94 +597,71 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IPlay
         {
             if (this.startServer())
             {
-                long var1 = System.currentTimeMillis();
-
-                for (long var50 = 0L; this.serverRunning; this.serverIsRunning = true)
+                // Spigot start
+                for (long lastTick = 0L; this.serverRunning; this.serverIsRunning = true)
                 {
-                    long var5 = System.currentTimeMillis();
-                    long var7 = var5 - var1;
-
-                    if (var7 > 2000L && var1 - this.timeOfLastWarning >= 15000L)
-                    {
-                        if (this.server.getWarnOnOverload()) // CraftBukkit - Added option to suppress warning messages
-                        {
-                            logger.warning("Can\'t keep up! Did the system time change, or is the server overloaded?");
-                        }
-
-                        var7 = 2000L;
-                        this.timeOfLastWarning = var1;
-                    }
-
-                    if (var7 < 0L)
-                    {
-                        logger.warning("Time ran backwards! Did the system time change?");
-                        var7 = 0L;
-                    }
-
-                    var50 += var7;
-                    var1 = var5;
+                    long curTime = System.nanoTime();
+                    long wait = TICK_TIME - (curTime - lastTick);
 
-                    if (this.worlds.get(0).areAllPlayersAsleep())   // CraftBukkit
+                    if (wait > 0)
                     {
-                        this.tick();
-                        var50 = 0L;
-                    }
-                    else
-                    {
-                        while (var50 > 50L)
-                        {
-                            MinecraftServer.currentTick = (int)(System.currentTimeMillis() / 50);  // CraftBukkit
-                            var50 -= 50L;
-                            this.tick();
-                        }
+                        Thread.sleep(wait / 1000000);
+                        continue;
                     }
 
-                    Thread.sleep(1L);
+                    currentTPS = (currentTPS * 0.95) + (1E9 / (curTime - lastTick) * 0.05);
+                    lastTick = curTime;
+                    MinecraftServer.currentTick++;
+                    this.tick();
                 }
+
+                // Spigot end
             }
             else
             {
                 this.finalTick((CrashReport)null);
             }
         }
-        catch (Throwable var48)
+        catch (Throwable var1)
         {
-            var48.printStackTrace();
-            logger.log(Level.SEVERE, "Encountered an unexpected exception " + var48.getClass().getSimpleName(), var48);
-            CrashReport var2 = null;
+            var1.printStackTrace();
+            logger.log(Level.SEVERE, "Encountered an unexpected exception " + var1.getClass().getSimpleName(), var1);
+            CrashReport var50 = null;
 
-            if (var48 instanceof ReportedException)
+            if (var1 instanceof ReportedException)
             {
-                var2 = this.addServerInfoToCrashReport(((ReportedException)var48).getCrashReport());
+                var50 = this.addServerInfoToCrashReport(((ReportedException) var1).getCrashReport());
             }
             else
             {
-                var2 = this.addServerInfoToCrashReport(new CrashReport("Exception in server tick loop", var48));
+                var50 = this.addServerInfoToCrashReport(new CrashReport("Exception in server tick loop", var1));
             }
 
-            File var3 = new File(new File(this.getDataDirectory(), "crash-reports"), "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-server.txt");
+            File var5 = new File(new File(this.getDataDirectory(), "crash-reports"), "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-server.txt");
 
-            if (var2.saveToFile(var3))
+            if (var50.saveToFile(var5))
             {
-                logger.severe("This crash report has been saved to: " + var3.getAbsolutePath());
+                logger.severe("This crash report has been saved to: " + var5.getAbsolutePath());
             }
             else
             {
                 logger.severe("We were unable to save this crash report to disk.");
             }
 
-            this.finalTick(var2);
+            this.finalTick(var50);
         }
         finally
         {
+            org.bukkit.craftbukkit.util.WatchdogThread.stopping(); // Spigot
+
             try
             {
                 this.stopServer();
                 this.serverStopped = true;
             }
-            catch (Throwable var46)
+            catch (Throwable var7)
             {
-                var46.printStackTrace();
+                var7.printStackTrace();
             }
             finally
             {
@@ -852,6 +834,7 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IPlay
         }
 
         this.theProfiler.endSection();
+        org.bukkit.craftbukkit.util.WatchdogThread.tick(); // Spigot
     }
 
     public boolean getAllowNether()
@@ -963,6 +946,7 @@ public abstract class MinecraftServer implements ICommandSender, Runnable, IPlay
                 dedicatedserver.an();
             }
             */
+            dedicatedserver.primaryThread.setUncaughtExceptionHandler(new org.bukkit.craftbukkit.util.ExceptionHandler()); // Spigot
             dedicatedserver.primaryThread.start();
             // Runtime.getRuntime().addShutdownHook(new ThreadShutdown(dedicatedserver));
             // CraftBukkit end
diff --git a/src/minecraft/net/minecraft/server/management/ServerConfigurationManager.java b/src/minecraft/net/minecraft/server/management/ServerConfigurationManager.java
index b3d8c03..ec3f788 100644
--- a/src/minecraft/net/minecraft/server/management/ServerConfigurationManager.java
+++ b/src/minecraft/net/minecraft/server/management/ServerConfigurationManager.java
@@ -345,7 +345,7 @@ public abstract class ServerConfigurationManager
         }
         else if (!this.isAllowedToLogin(s))
         {
-            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, "You are not white-listed on this server!");
+            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, cserver.whitelistMessage); // Spigot
         }
         else
         {
@@ -1203,7 +1203,16 @@ public abstract class ServerConfigurationManager
     {
         while (!this.playerEntityList.isEmpty())
         {
-            ((EntityPlayerMP) this.playerEntityList.get(0)).playerNetServerHandler.kickPlayerFromServer(this.mcServer.server.getShutdownMessage()); // CraftBukkit - add custom shutdown message
+            // Spigot start
+            EntityPlayerMP p = (EntityPlayerMP) this.playerEntityList.get(0);
+            p.playerNetServerHandler.kickPlayerFromServer(this.mcServer.server.getShutdownMessage());
+
+            if ((!this.playerEntityList.isEmpty()) && (this.playerEntityList.get(0) == p))
+            {
+                this.playerEntityList.remove(0); // Prevent shutdown hang if already disconnected
+            }
+
+            // Spigot end
         }
     }
 
diff --git a/src/minecraft/net/minecraft/world/SpawnerAnimals.java b/src/minecraft/net/minecraft/world/SpawnerAnimals.java
index 02c50ee..a80eb5a 100644
--- a/src/minecraft/net/minecraft/world/SpawnerAnimals.java
+++ b/src/minecraft/net/minecraft/world/SpawnerAnimals.java
@@ -32,6 +32,7 @@ public final class SpawnerAnimals
 
     /** An array of entity classes that spawn at night. */
     protected static final Class[] nightSpawnEntities = new Class[] {EntitySpider.class, EntityZombie.class, EntitySkeleton.class};
+    private static byte spawnRadius = 0; // Spigot
 
     /**
      * Given a chunk, find a random position in it.
@@ -61,12 +62,25 @@ public final class SpawnerAnimals
             int var4;
             int var7;
 
+            // Spigot start - limit radius to spawn distance (chunks aren't loaded)
+            if (spawnRadius == 0)
+            {
+                spawnRadius = (byte) par0WorldServer.getServer().getViewDistance();
+
+                if (spawnRadius > 8)
+                {
+                    spawnRadius = 8;
+                }
+            }
+
+            // Spigot end
+
             for (var4 = 0; var4 < par0WorldServer.playerEntities.size(); ++var4)
             {
                 EntityPlayer var5 = (EntityPlayer)par0WorldServer.playerEntities.get(var4);
                 int var6 = MathHelper.floor_double(var5.posX / 16.0D);
                 var7 = MathHelper.floor_double(var5.posZ / 16.0D);
-                byte var8 = 8;
+                byte var8 = spawnRadius; // Spigot - replace 8 with view distance constrained value
 
                 for (int var9 = -var8; var9 <= var8; ++var9)
                 {
@@ -125,14 +139,16 @@ public final class SpawnerAnimals
                     continue;
                 }
 
+                int mobcnt = 0;
                 // CraftBukkit end
 
-                if ((!var34.getPeacefulCreature() || par2) && (var34.getPeacefulCreature() || par1) && (!var34.getAnimal() || par3) && par0WorldServer.countEntities(var34.getCreatureClass()) <= limit * eligibleChunksForSpawning.size() / 256)   // CraftBukkit - use per-world limits
+                if ((!var34.getPeacefulCreature() || par2) && (var34.getPeacefulCreature() || par1) && (!var34.getAnimal() || par3) && (mobcnt = par0WorldServer.countEntities(var34.getCreatureClass())) <= limit * eligibleChunksForSpawning.size() / 256)   // CraftBukkit - use per-world limits
                 {
                     Iterator var35 = eligibleChunksForSpawning.keySet().iterator();
+                    int var37 = (limit * eligibleChunksForSpawning.size() / 256) - mobcnt + 1; // CraftBukkit - up to 1 more than limit
                     label110:
 
-                    while (var35.hasNext())
+                    while (var35.hasNext() && (var37 > 0))   // Spigot - while more allowed
                     {
                         // CraftBukkit start
                         long key = ((Long) var35.next()).longValue();
@@ -141,98 +157,106 @@ public final class SpawnerAnimals
                         {
                             ChunkPosition chunkposition = getRandomSpawningPointInChunk(par0WorldServer, LongHash.msw(key), LongHash.lsw(key));
                             // CraftBukkit end
-                            int var37 = chunkposition.x;
-                            int var36 = chunkposition.y;
-                            int var38 = chunkposition.z;
+                            int var36 = chunkposition.x;
+                            int var38 = chunkposition.y;
+                            int var13 = chunkposition.z;
 
-                            if (!par0WorldServer.isBlockNormalCube(var37, var36, var38) && par0WorldServer.getBlockMaterial(var37, var36, var38) == var34.getCreatureMaterial())
+                            if (!par0WorldServer.isBlockNormalCube(var36, var38, var13) && par0WorldServer.getBlockMaterial(var36, var38, var13) == var34.getCreatureMaterial())
                             {
-                                int var13 = 0;
                                 int var14 = 0;
+                                int var15 = 0;
 
-                                while (var14 < 3)
+                                while (var15 < 3)
                                 {
-                                    int var15 = var37;
                                     int var16 = var36;
                                     int var17 = var38;
-                                    byte var18 = 6;
-                                    SpawnListEntry var19 = null;
-                                    int var20 = 0;
+                                    int var18 = var13;
+                                    byte var19 = 6;
+                                    SpawnListEntry var20 = null;
+                                    int var21 = 0;
 
                                     while (true)
                                     {
-                                        if (var20 < 4)
+                                        if (var21 < 4)
                                         {
                                             label103:
                                             {
-                                                var15 += par0WorldServer.rand.nextInt(var18) - par0WorldServer.rand.nextInt(var18);
-                                                var16 += par0WorldServer.rand.nextInt(1) - par0WorldServer.rand.nextInt(1);
-                                                var17 += par0WorldServer.rand.nextInt(var18) - par0WorldServer.rand.nextInt(var18);
+                                                var16 += par0WorldServer.rand.nextInt(var19) - par0WorldServer.rand.nextInt(var19);
+                                                var17 += par0WorldServer.rand.nextInt(1) - par0WorldServer.rand.nextInt(1);
+                                                var18 += par0WorldServer.rand.nextInt(var19) - par0WorldServer.rand.nextInt(var19);
 
-                                                if (canCreatureTypeSpawnAtLocation(var34, par0WorldServer, var15, var16, var17))
+                                                if (canCreatureTypeSpawnAtLocation(var34, par0WorldServer, var16, var17, var18))
                                                 {
-                                                    float var21 = (float) var15 + 0.5F;
-                                                    float var22 = (float) var16;
-                                                    float var23 = (float) var17 + 0.5F;
+                                                    float var22 = (float) var16 + 0.5F;
+                                                    float var23 = (float) var17;
+                                                    float var24 = (float)var18 + 0.5F;
 
-                                                    if (par0WorldServer.getClosestPlayer((double) var21, (double) var22, (double) var23, 24.0D) == null)
+                                                    if (par0WorldServer.getClosestPlayer((double) var22, (double) var23, (double) var24, 24.0D) == null)
                                                     {
-                                                        float var24 = var21 - (float) var12.posX;
-                                                        float var25 = var22 - (float) var12.posY;
-                                                        float var26 = var23 - (float) var12.posZ;
-                                                        float var27 = var24 * var24 + var25 * var25 + var26 * var26;
+                                                        float var25 = var22 - (float) var12.posX;
+                                                        float var26 = var23 - (float) var12.posY;
+                                                        float var27 = var24 - (float) var12.posZ;
+                                                        float var28 = var25 * var25 + var26 * var26 + var27 * var27;
 
-                                                        if (var27 >= 576.0F)
+                                                        if (var28 >= 576.0F)
                                                         {
-                                                            if (var19 == null)
+                                                            if (var20 == null)
                                                             {
-                                                                var19 = par0WorldServer.spawnRandomCreature(var34, var15, var16, var17);
+                                                                var20 = par0WorldServer.spawnRandomCreature(var34, var16, var17, var18);
 
-                                                                if (var19 == null)
+                                                                if (var20 == null)
                                                                 {
                                                                     break label103;
                                                                 }
                                                             }
 
-                                                            EntityLiving var28;
+                                                            EntityLiving var29;
 
                                                             try
                                                             {
-                                                                var28 = (EntityLiving) var19.entityClass.getConstructor(new Class[] { World.class}).newInstance(new Object[] { par0WorldServer});
+                                                                var29 = (EntityLiving) var20.entityClass.getConstructor(new Class[] { World.class}).newInstance(new Object[] { par0WorldServer});
                                                             }
-                                                            catch (Exception var29)
+                                                            catch (Exception var30)
                                                             {
-                                                                var29.printStackTrace();
+                                                                var30.printStackTrace();
                                                                 return var4;
                                                             }
 
-                                                            var28.setLocationAndAngles((double) var21, (double) var22, (double) var23, par0WorldServer.rand.nextFloat() * 360.0F, 0.0F);
+                                                            var29.setLocationAndAngles((double) var22, (double) var23, (double) var24, par0WorldServer.rand.nextFloat() * 360.0F, 0.0F);
 
-                                                            if (var28.getCanSpawnHere())
+                                                            if (var29.getCanSpawnHere())
                                                             {
-                                                                ++var13;
+                                                                ++var14;
                                                                 // CraftBukkit start - added a reason for spawning this creature, moved a(entityliving, world...) up
-                                                                creatureSpecificInit(var28, par0WorldServer, var21, var22, var23);
-                                                                par0WorldServer.addEntity(var28, SpawnReason.NATURAL);
-
+                                                                creatureSpecificInit(var29, par0WorldServer, var22, var23, var24);
+                                                                par0WorldServer.addEntity(var29, SpawnReason.NATURAL);
                                                                 // CraftBukkit end
-                                                                if (var13 >= var28.getMaxSpawnedInChunk())
+                                                                // Spigot start
+                                                                var37--;
+
+                                                                if (var37 <= 0)   // If we're past limit, stop spawn
+                                                                {
+                                                                    continue label110;
+                                                                }
+
+                                                                // Spigot end
+                                                                if (var14 >= var29.getMaxSpawnedInChunk())
                                                                 {
                                                                     continue label110;
                                                                 }
                                                             }
 
-                                                            var4 += var13;
+                                                            var4 += var14;
                                                         }
                                                     }
                                                 }
 
-                                                ++var20;
+                                                ++var21;
                                                 continue;
                                             }
                                         }
 
-                                        ++var14;
+                                        ++var15;
                                         break;
                                     }
                                 }
diff --git a/src/minecraft/net/minecraft/world/World.java b/src/minecraft/net/minecraft/world/World.java
index 9d48d17..4175c1f 100644
--- a/src/minecraft/net/minecraft/world/World.java
+++ b/src/minecraft/net/minecraft/world/World.java
@@ -21,6 +21,7 @@ import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityLiving;
 import net.minecraft.entity.item.EntityItem;
 import net.minecraft.entity.item.EntityMinecart;
+import net.minecraft.entity.item.EntityXPOrb;
 import net.minecraft.entity.monster.EntityGhast;
 import net.minecraft.entity.monster.EntityGolem;
 import net.minecraft.entity.monster.EntityMob;
@@ -29,6 +30,7 @@ import net.minecraft.entity.passive.EntityAnimal;
 import net.minecraft.entity.passive.EntityWaterMob;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
+import net.minecraft.item.ItemStack;
 import net.minecraft.pathfinding.PathEntity;
 import net.minecraft.pathfinding.PathFinder;
 import net.minecraft.profiler.Profiler;
@@ -146,7 +148,8 @@ public abstract class World implements IBlockAccess
     // CraftBukkit start - public, longhashset
     public boolean spawnHostileMobs = true;
     public boolean spawnPeacefulMobs = true;
-    protected LongHashSet activeChunkSet = new LongHashSet();
+    protected gnu.trove.map.hash.TLongShortHashMap activeChunkSet; // Spigot
+    private org.bukkit.craftbukkit.util.LightningSimulator lightningSim = new org.bukkit.craftbukkit.util.LightningSimulator(this); // Spigot
     public long ticksPerAnimalSpawns;
     public long ticksPerMonsterSpawns;
     // CraftBukkit end
@@ -170,6 +173,23 @@ public abstract class World implements IBlockAccess
 
     /** This is set to true for client worlds, and false for server worlds. */
     public boolean isRemote;
+    // Spigot start
+
+    public static final long chunkToKey(int x, int z)
+    {
+        long k = ((((long)x) & 0xFFFF0000L) << 16) | ((((long)x) & 0x0000FFFFL) << 0);
+        k |= ((((long)z) & 0xFFFF0000L) << 32) | ((((long)z) & 0x0000FFFFL) << 16);
+        return k;
+    }
+    public static final int keyToX(long k)
+    {
+        return (int)(((k >> 16) & 0xFFFF0000) | (k & 0x0000FFFF));
+    }
+    public static final int keyToZ(long k)
+    {
+        return (int)(((k >> 32) & 0xFFFF0000L) | ((k >> 16) & 0x0000FFFF));
+    }
+    // Spigot end
 
     /**
      * Gets the biome for a given set of x/z coordinates
@@ -203,6 +223,7 @@ public abstract class World implements IBlockAccess
     int lastXAccessed = Integer.MIN_VALUE;
     int lastZAccessed = Integer.MIN_VALUE;
     final Object chunkLock = new Object();
+    private byte chunkTickRadius;
 
     public CraftWorld getWorld()
     {
@@ -218,10 +239,16 @@ public abstract class World implements IBlockAccess
     public World(ISaveHandler idatamanager, String s, WorldSettings worldsettings, WorldProvider worldprovider, Profiler methodprofiler, ChunkGenerator gen, org.bukkit.World.Environment env)
     {
         this.generator = gen;
+        this.worldInfo = idatamanager.loadWorldInfo(); // Spigot
         this.world = new CraftWorld((WorldServer) this, gen, env);
         this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
         this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
+        this.chunkTickRadius = (byte)((this.getServer().getViewDistance() < 7) ? this.getServer().getViewDistance() : 7); // CraftBukkit - don't tick chunks we don't load for player
         // CraftBukkit end
+        // Spigot start
+        this.activeChunkSet = new gnu.trove.map.hash.TLongShortHashMap(getWorld().growthPerTick * 5, 0.7f, Long.MIN_VALUE, Short.MIN_VALUE);
+        activeChunkSet.setAutoCompactionFactor(0.0F);
+        // Spigot end
         this.ambientTickCountdown = this.rand.nextInt(12000);
         this.lightUpdateBlockList = new int['\u8000'];
         this.entitiesWithinAABBExcludingEntity = new UnsafeList(); // CraftBukkit - ArrayList -> UnsafeList
@@ -229,8 +256,8 @@ public abstract class World implements IBlockAccess
         this.saveHandler = idatamanager;
         this.theProfiler = methodprofiler;
         this.mapStorage = new MapStorage(idatamanager);
-        this.worldInfo = idatamanager.loadWorldInfo();
 
+        // this.worldData = idatamanager.getWorldData(); Moved up
         if (worldprovider != null)
         {
             this.provider = worldprovider;
@@ -1452,6 +1479,69 @@ public abstract class World implements IBlockAccess
         else if (entity instanceof EntityItem)
         {
             event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
+            // Spigot start
+            ItemStack item = ((EntityItem) entity).func_92014_d();
+            int maxSize = item.getMaxStackSize();
+
+            if (item.stackSize < maxSize)
+            {
+                double radius = this.getWorld().itemMergeRadius;
+
+                if (radius > 0)
+                {
+                    List<Entity> entities = this.getEntitiesWithinAABBExcludingEntity(entity, entity.boundingBox.expand(radius, radius, radius));
+
+                    for (Entity e : entities)
+                    {
+                        if (e instanceof EntityItem)
+                        {
+                            EntityItem loopItem = (EntityItem) e;
+                            ItemStack loopStack = loopItem.func_92014_d();
+
+                            if (!loopItem.isDead && loopStack.itemID == item.itemID && loopStack.getItemDamage() == item.getItemDamage())
+                            {
+                                if (loopStack.stackTagCompound == null || item.stackTagCompound == null || !loopStack.stackTagCompound.equals(item.stackTagCompound))
+                                {
+                                    int toAdd = Math.min(loopStack.stackSize, maxSize - item.stackSize);
+                                    item.stackSize += toAdd;
+                                    loopStack.stackSize -= toAdd;
+
+                                    if (loopStack.stackSize <= 0)
+                                    {
+                                        loopItem.setDead();
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        else if (entity instanceof EntityXPOrb)
+        {
+            EntityXPOrb xp = (EntityXPOrb) entity;
+            double radius = this.getWorld().expMergeRadius;
+
+            if (radius > 0)
+            {
+                List<Entity> entities = this.getEntitiesWithinAABBExcludingEntity(entity, entity.boundingBox.expand(radius, radius, radius));
+
+                for (Entity e : entities)
+                {
+                    if (e instanceof EntityXPOrb)
+                    {
+                        EntityXPOrb loopItem = (EntityXPOrb) e;
+
+                        if (!loopItem.isDead)
+                        {
+                            xp.xpValue += loopItem.xpValue;
+                            loopItem.setDead();
+                        }
+                    }
+                }
+            }
+
+            // Spigot end
         }
         else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile)
         {
@@ -1585,43 +1675,84 @@ public abstract class World implements IBlockAccess
         int var6 = MathHelper.floor_double(par2AxisAlignedBB.maxY + 1.0D);
         int var7 = MathHelper.floor_double(par2AxisAlignedBB.minZ);
         int var8 = MathHelper.floor_double(par2AxisAlignedBB.maxZ + 1.0D);
+        // Spigot start
+        int ystart = ((var5 - 1) < 0) ? 0 : (var5 - 1);
 
-        for (int var9 = var3; var9 < var4; ++var9)
+        for (int chunkx = (var3 >> 4); chunkx <= ((var4 - 1) >> 4); chunkx++)
         {
-            for (int var10 = var7; var10 < var8; ++var10)
+            int cx = chunkx << 4;
+
+            for (int chunkz = (var7 >> 4); chunkz <= ((var8 - 1) >> 4); chunkz++)
             {
-                if (this.blockExists(var9, 64, var10))
+                if (!this.chunkExists(chunkx, chunkz))
                 {
-                    for (int var11 = var5 - 1; var11 < var6; ++var11)
-                    {
-                        Block var12 = Block.blocksList[this.getBlockId(var9, var11, var10)];
+                    continue;
+                }
+
+                int cz = chunkz << 4;
+                Chunk chunk = this.getChunkFromChunkCoords(chunkx, chunkz);
+                // Compute ranges within chunk
+                int xstart = (var3 < cx) ? cx : var3;
+                int xend = (var4 < (cx + 16)) ? var4 : (cx + 16);
+                int zstart = (var7 < cz) ? cz : var7;
+                int zend = (var8 < (cz + 16)) ? var8 : (cz + 16);
 
-                        if (var12 != null)
+                // Loop through blocks within chunk
+                for (int x = xstart; x < xend; x++)
+                {
+                    for (int z = zstart; z < zend; z++)
+                    {
+                        for (int y = ystart; y < var6; y++)
                         {
-                            var12.addCollidingBlockToList(this, var9, var11, var10, par2AxisAlignedBB, this.collidingBoundingBoxes, par1Entity);
+                            int blkid = chunk.getBlockID(x - cx, y, z - cz);
+
+                            if (blkid > 0)
+                            {
+                                Block block = Block.blocksList[blkid];
+
+                                if (block != null)
+                                {
+                                    block.addCollidingBlockToList(this, x, y, z, par2AxisAlignedBB, this.collidingBoundingBoxes, par1Entity);
+                                }
+                            }
                         }
                     }
                 }
             }
         }
 
-        double var14 = 0.25D;
-        List var16 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var14, var14, var14));
+        /*
+        for (int k1 = i; k1 < j; ++k1) {
+            for (int l1 = i1; l1 < j1; ++l1) {
+                if (this.isLoaded(k1, 64, l1)) {
+                    for (int i2 = k - 1; i2 < l; ++i2) {
+                        Block block = Block.byId[this.getTypeId(k1, i2, l1)];
+
+                        if (block != null) {
+                            block.a(this, k1, i2, l1, axisalignedbb, this.L, entity);
+                        }
+                    }
+                }
+            }
+        }
+        */// Spigot end
+        double var9 = 0.25D;
+        List var10 = this.getEntitiesWithinAABBExcludingEntity(par1Entity, par2AxisAlignedBB.expand(var9, var9, var9));
 
-        for (int var15 = 0; var15 < var16.size(); ++var15)
+        for (int var11 = 0; var11 < var10.size(); ++var11)
         {
-            AxisAlignedBB var13 = ((Entity)var16.get(var15)).getBoundingBox();
+            AxisAlignedBB var12 = ((Entity) var10.get(var11)).getBoundingBox();
 
-            if (var13 != null && var13.intersectsWith(par2AxisAlignedBB))
+            if (var12 != null && var12.intersectsWith(par2AxisAlignedBB))
             {
-                this.collidingBoundingBoxes.add(var13);
+                this.collidingBoundingBoxes.add(var12);
             }
 
-            var13 = par1Entity.getCollisionBox((Entity)var16.get(var15));
+            var12 = par1Entity.getCollisionBox((Entity) var10.get(var11));
 
-            if (var13 != null && var13.intersectsWith(par2AxisAlignedBB))
+            if (var12 != null && var12.intersectsWith(par2AxisAlignedBB))
             {
-                this.collidingBoundingBoxes.add(var13);
+                this.collidingBoundingBoxes.add(var12);
             }
         }
 
@@ -2021,98 +2152,138 @@ public abstract class World implements IBlockAccess
         this.updateEntityWithOptionalForce(par1Entity, true);
     }
 
-    /**
-     * Will update the entity in the world if the chunk the entity is in is currently loaded or its forced to update.
-     * Args: entity, forceUpdate
-     */
-    public void updateEntityWithOptionalForce(Entity par1Entity, boolean par2)
+    // Spigot start
+    public int tickEntityExceptions = 0;
+    public void updateEntityWithOptionalForce(final Entity par1Entity, final boolean par2)
     {
-        int var3 = MathHelper.floor_double(par1Entity.posX);
-        int var4 = MathHelper.floor_double(par1Entity.posZ);
-        byte var5 = 32;
+        if (par1Entity == null)
+        {
+            return;
+        }
 
-        if (!par2 || this.checkChunksExist(var3 - var5, 0, var4 - var5, var3 + var5, 0, var4 + var5))
+        try
         {
-            par1Entity.lastTickPosX = par1Entity.posX;
-            par1Entity.lastTickPosY = par1Entity.posY;
-            par1Entity.lastTickPosZ = par1Entity.posZ;
-            par1Entity.prevRotationYaw = par1Entity.rotationYaw;
-            par1Entity.prevRotationPitch = par1Entity.rotationPitch;
+            tickEntity(par1Entity, par2);
+        }
+        catch (Exception var3)
+        {
+            try
+            {
+                tickEntityExceptions++;
+                List<String> var4 = new ArrayList<String>();
+                var4.add("Spigot has detected an unexpected exception while handling");
 
-            if (par2 && par1Entity.addedToChunk)
+                if (!(par1Entity instanceof EntityPlayerMP))
+                {
+                    var4.add("entity " + par1Entity.toString() + " (id: " + par1Entity.entityId + ")");
+                    var4.add("Spigot will kill the entity from the game instead of crashing your server.");
+                    par1Entity.setDead();
+                }
+                else
+                {
+                    var4.add("player '" + ((EntityPlayerMP) par1Entity).username + "'. They will be kicked instead of crashing your server.");
+                    ((EntityPlayerMP) par1Entity).getBukkitEntity().kickPlayer("The server experienced and error and was forced to kick you. Please re-login.");
+                }
+
+                org.bukkit.craftbukkit.util.ExceptionReporter.handle(var3, var4.toArray(new String[0]));
+            }
+            catch (Throwable var5)
             {
-                if (par1Entity.ridingEntity != null)
+                org.bukkit.craftbukkit.util.ExceptionReporter.handle(var5, "Spigot has detected an unexpected exception while attempting to handle an exception (yes you read that correctly).");
+                Bukkit.shutdown();
+            }
+        }
+    }
+
+    public void tickEntity(Entity entity, boolean flag)
+    {
+        // Spigot end
+        int i = MathHelper.floor_double(entity.posX);
+        int j = MathHelper.floor_double(entity.posZ);
+        byte b0 = 32;
+
+        if (!flag || this.checkChunksExist(i - b0, 0, j - b0, i + b0, 0, j + b0))
+        {
+            entity.lastTickPosX = entity.posX;
+            entity.lastTickPosY = entity.posY;
+            entity.lastTickPosZ = entity.posZ;
+            entity.prevRotationYaw = entity.rotationYaw;
+            entity.prevRotationPitch = entity.rotationPitch;
+
+            if (flag && entity.addedToChunk)
+            {
+                if (entity.ridingEntity != null)
                 {
-                    par1Entity.updateRidden();
+                    entity.updateRidden();
                 }
                 else
                 {
-                    ++par1Entity.ticksExisted;
-                    par1Entity.onUpdate();
+                    ++entity.ticksExisted;
+                    entity.onUpdate();
                 }
             }
 
             this.theProfiler.startSection("chunkCheck");
 
-            if (Double.isNaN(par1Entity.posX) || Double.isInfinite(par1Entity.posX))
+            if (Double.isNaN(entity.posX) || Double.isInfinite(entity.posX))
             {
-                par1Entity.posX = par1Entity.lastTickPosX;
+                entity.posX = entity.lastTickPosX;
             }
 
-            if (Double.isNaN(par1Entity.posY) || Double.isInfinite(par1Entity.posY))
+            if (Double.isNaN(entity.posY) || Double.isInfinite(entity.posY))
             {
-                par1Entity.posY = par1Entity.lastTickPosY;
+                entity.posY = entity.lastTickPosY;
             }
 
-            if (Double.isNaN(par1Entity.posZ) || Double.isInfinite(par1Entity.posZ))
+            if (Double.isNaN(entity.posZ) || Double.isInfinite(entity.posZ))
             {
-                par1Entity.posZ = par1Entity.lastTickPosZ;
+                entity.posZ = entity.lastTickPosZ;
             }
 
-            if (Double.isNaN((double)par1Entity.rotationPitch) || Double.isInfinite((double)par1Entity.rotationPitch))
+            if (Double.isNaN((double) entity.rotationPitch) || Double.isInfinite((double) entity.rotationPitch))
             {
-                par1Entity.rotationPitch = par1Entity.prevRotationPitch;
+                entity.rotationPitch = entity.prevRotationPitch;
             }
 
-            if (Double.isNaN((double)par1Entity.rotationYaw) || Double.isInfinite((double)par1Entity.rotationYaw))
+            if (Double.isNaN((double) entity.rotationYaw) || Double.isInfinite((double) entity.rotationYaw))
             {
-                par1Entity.rotationYaw = par1Entity.prevRotationYaw;
+                entity.rotationYaw = entity.prevRotationYaw;
             }
 
-            int var6 = MathHelper.floor_double(par1Entity.posX / 16.0D);
-            int var7 = MathHelper.floor_double(par1Entity.posY / 16.0D);
-            int var8 = MathHelper.floor_double(par1Entity.posZ / 16.0D);
+            int k = MathHelper.floor_double(entity.posX / 16.0D);
+            int l = MathHelper.floor_double(entity.posY / 16.0D);
+            int i1 = MathHelper.floor_double(entity.posZ / 16.0D);
 
-            if (!par1Entity.addedToChunk || par1Entity.chunkCoordX != var6 || par1Entity.chunkCoordY != var7 || par1Entity.chunkCoordZ != var8)
+            if (!entity.addedToChunk || entity.chunkCoordX != k || entity.chunkCoordY != l || entity.chunkCoordZ != i1)
             {
-                if (par1Entity.addedToChunk && this.chunkExists(par1Entity.chunkCoordX, par1Entity.chunkCoordZ))
+                if (entity.addedToChunk && this.chunkExists(entity.chunkCoordX, entity.chunkCoordZ))
                 {
-                    this.getChunkFromChunkCoords(par1Entity.chunkCoordX, par1Entity.chunkCoordZ).removeEntityAtIndex(par1Entity, par1Entity.chunkCoordY);
+                    this.getChunkFromChunkCoords(entity.chunkCoordX, entity.chunkCoordZ).removeEntityAtIndex(entity, entity.chunkCoordY);
                 }
 
-                if (this.chunkExists(var6, var8))
+                if (this.chunkExists(k, i1))
                 {
-                    par1Entity.addedToChunk = true;
-                    this.getChunkFromChunkCoords(var6, var8).addEntity(par1Entity);
+                    entity.addedToChunk = true;
+                    this.getChunkFromChunkCoords(k, i1).addEntity(entity);
                 }
                 else
                 {
-                    par1Entity.addedToChunk = false;
+                    entity.addedToChunk = false;
                 }
             }
 
             this.theProfiler.endSection();
 
-            if (par2 && par1Entity.addedToChunk && par1Entity.riddenByEntity != null)
+            if (flag && entity.addedToChunk && entity.riddenByEntity != null)
             {
-                if (!par1Entity.riddenByEntity.isDead && par1Entity.riddenByEntity.ridingEntity == par1Entity)
+                if (!entity.riddenByEntity.isDead && entity.riddenByEntity.ridingEntity == entity)
                 {
-                    this.updateEntity(par1Entity.riddenByEntity);
+                    this.updateEntity(entity.riddenByEntity);
                 }
                 else
                 {
-                    par1Entity.riddenByEntity.ridingEntity = null;
-                    par1Entity.riddenByEntity = null;
+                    entity.riddenByEntity.ridingEntity = null;
+                    entity.riddenByEntity = null;
                 }
             }
         }
@@ -2731,6 +2902,7 @@ public abstract class World implements IBlockAccess
     {
         if (!this.provider.hasNoSky)
         {
+            lightningSim.onTick(); // Spigot
             int var1 = this.worldInfo.getThunderTime();
 
             if (var1 <= 0)
@@ -2846,6 +3018,11 @@ public abstract class World implements IBlockAccess
         this.worldInfo.setRainTime(1);
     }
 
+    // Spigot start
+    public int aggregateTicks = 1;
+    protected float modifiedOdds = 100F;
+    public float growthOdds = 100F;
+
     protected void setActivePlayerChunksAndCheckLight()
     {
         // this.chunkTickList.clear(); // CraftBukkit - removed
@@ -2854,32 +3031,57 @@ public abstract class World implements IBlockAccess
         EntityPlayer var2;
         int var3;
         int var4;
+        final int var5 = this.getWorld().growthPerTick;
+
+        if (var5 <= 0)
+        {
+            return;
+        }
+
+        if (playerEntities.size() == 0)
+        {
+            return;
+        }
+
+        //Keep chunks with growth inside of the optimal chunk range
+        int var6 = Math.min(200, Math.max(1, (int)(((var5 - playerEntities.size()) / (double)playerEntities.size()) + 0.5)));
+        int var7 = 3 + var6 / 30;
+
+        if (var7 > chunkTickRadius)  // Limit to normal tick radius - including view distance
+        {
+            var7 = chunkTickRadius;
+        }
+
+        //odds of growth happening vs growth happening in vanilla
+        final float var8 = Math.max(35, Math.min(100, ((var6 + 1) * 100F) / 15F));
+        this.modifiedOdds = var8;
+        this.growthOdds = var8;
 
         for (var1 = 0; var1 < this.playerEntities.size(); ++var1)
         {
             var2 = (EntityPlayer)this.playerEntities.get(var1);
-            var3 = MathHelper.floor_double(var2.posX / 16.0D);
-            var4 = MathHelper.floor_double(var2.posZ / 16.0D);
-            byte var5 = 7;
-
-            for (int var6 = -var5; var6 <= var5; ++var6)
+            int chunkX = MathHelper.floor_double(var2.posX / 16.0D);
+            int chunkZ = MathHelper.floor_double(var2.posZ / 16.0D);
+            //Always update the chunk the player is on
+            long key = chunkToKey(chunkX, chunkZ);
+            int existingPlayers = Math.max(0, activeChunkSet.get(key)); //filter out -1's
+            activeChunkSet.put(key, (short)(existingPlayers + 1));
+
+            //Check and see if we update the chunks surrounding the player this tick
+            for (int chunk = 0; chunk < var6; chunk++)
             {
-                for (int var7 = -var5; var7 <= var5; ++var7)
-                {
-                    // CraftBukkit start - don't tick chunks queued for unload
-                    ChunkProviderServer chunkProviderServer = ((WorldServer) var2.worldObj).theChunkProviderServer;
+                int dx = (rand.nextBoolean() ? 1 : -1) * rand.nextInt(var7);
+                int dz = (rand.nextBoolean() ? 1 : -1) * rand.nextInt(var7);
+                long hash = chunkToKey(dx + chunkX, dz + chunkZ);
 
-                    if (chunkProviderServer.chunksToUnload.contains(var6 + var3, var7 + var4))
-                    {
-                        continue;
-                    }
-
-                    // CraftBukkit end
-                    this.activeChunkSet.add(org.bukkit.craftbukkit.util.LongHash.toLong(var6 + var3, var7 + var4)); // CraftBukkit
+                if (!activeChunkSet.contains(hash) && this.chunkExists(dx + chunkX, dz + chunkZ))
+                {
+                    activeChunkSet.put(hash, (short) - 1); //no players
                 }
             }
         }
 
+        // Spigot End
         this.theProfiler.endSection();
 
         if (this.ambientTickCountdown > 0)
@@ -2889,14 +3091,14 @@ public abstract class World implements IBlockAccess
 
         this.theProfiler.startSection("playerCheckLight");
 
-        if (!this.playerEntities.isEmpty())
+        if (!this.playerEntities.isEmpty() && this.getWorld().randomLightingUpdates)   // Spigot
         {
             var1 = this.rand.nextInt(this.playerEntities.size());
             var2 = (EntityPlayer)this.playerEntities.get(var1);
             var3 = MathHelper.floor_double(var2.posX) + this.rand.nextInt(11) - 5;
             var4 = MathHelper.floor_double(var2.posY) + this.rand.nextInt(11) - 5;
-            int var8 = MathHelper.floor_double(var2.posZ) + this.rand.nextInt(11) - 5;
-            this.updateAllLightTypes(var3, var4, var8);
+            int j1 = MathHelper.floor_double(var2.posZ) + this.rand.nextInt(11) - 5;
+            this.updateAllLightTypes(var3, var4, j1);
         }
 
         this.theProfiler.endSection();
@@ -2933,14 +3135,24 @@ public abstract class World implements IBlockAccess
         par3Chunk.enqueueRelightChecks();
     }
 
+    // Spigot start
+
     /**
      * plays random cave ambient sounds and runs updateTick on random blocks within each chunk in the vacinity of a
      * player
      */
     protected void tickBlocksAndAmbiance()
     {
-        this.setActivePlayerChunksAndCheckLight();
+        try
+        {
+            this.setActivePlayerChunksAndCheckLight();
+        }
+        catch (Exception e)
+        {
+            org.bukkit.craftbukkit.util.ExceptionReporter.handle(e, "Spigot has detected an unexpected exception while ticking chunks");
+        }
     }
+    // Spigot end
 
     /**
      * checks to see if a given block is both water and is cold enough to freeze
@@ -3381,7 +3593,10 @@ public abstract class World implements IBlockAccess
      */
     public List getEntitiesWithinAABBExcludingEntity(Entity par1Entity, AxisAlignedBB par2AxisAlignedBB)
     {
-        this.entitiesWithinAABBExcludingEntity.clear();
+        // Spigot start
+        // this.O.clear();
+        ArrayList<?> entities = new ArrayList();
+        // Spigot end
         int var3 = MathHelper.floor_double((par2AxisAlignedBB.minX - 2.0D) / 16.0D);
         int var4 = MathHelper.floor_double((par2AxisAlignedBB.maxX + 2.0D) / 16.0D);
         int var5 = MathHelper.floor_double((par2AxisAlignedBB.minZ - 2.0D) / 16.0D);
@@ -3393,12 +3608,12 @@ public abstract class World implements IBlockAccess
             {
                 if (this.chunkExists(var7, var8))
                 {
-                    this.getChunkFromChunkCoords(var7, var8).getEntitiesWithinAABBForEntity(par1Entity, par2AxisAlignedBB, this.entitiesWithinAABBExcludingEntity);
+                    this.getChunkFromChunkCoords(var7, var8).getEntitiesWithinAABBForEntity(par1Entity, par2AxisAlignedBB, entities); // Spigot
                 }
             }
         }
 
-        return this.entitiesWithinAABBExcludingEntity;
+        return entities; // Spigot
     }
 
     /**
diff --git a/src/minecraft/net/minecraft/world/WorldServer.java b/src/minecraft/net/minecraft/world/WorldServer.java
index 95a498d..d213a42 100644
--- a/src/minecraft/net/minecraft/world/WorldServer.java
+++ b/src/minecraft/net/minecraft/world/WorldServer.java
@@ -1,13 +1,6 @@
 package net.minecraft.world;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Random;
-import java.util.Set;
-import java.util.TreeSet;
+import gnu.trove.iterator.TLongShortIterator;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockContainer;
 import net.minecraft.block.BlockEventData;
@@ -18,7 +11,6 @@ import net.minecraft.entity.Entity;
 import net.minecraft.entity.EntityTracker;
 import net.minecraft.entity.EnumCreatureType;
 import net.minecraft.entity.INpc;
-import net.minecraft.entity.effect.EntityLightningBolt;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.item.Item;
@@ -57,9 +49,19 @@ import net.minecraft.world.gen.ChunkProviderServer;
 import net.minecraft.world.gen.feature.WorldGeneratorBonusChest;
 import net.minecraft.world.storage.ISaveHandler;
 
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
+import java.util.TreeSet;
+
 // CraftBukkit start
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.util.LongHash;
+import org.bukkit.craftbukkit.util.LongObjectHashMap;
 
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
@@ -73,7 +75,7 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
     private final MinecraftServer mcServer;
     public EntityTracker theEntityTracker; // CraftBukkit - private final -> public
     private final PlayerManager thePlayerManager;
-    private Set field_73064_N;
+    private LongObjectHashMap<Set<NextTickListEntry>> field_73064_N; // CraftBukkit - change to something chunk friendly
 
     /** All work to do in future ticks. */
     private TreeSet pendingTickListEntries;
@@ -122,7 +124,7 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
 
         if (this.field_73064_N == null)
         {
-            this.field_73064_N = new HashSet();
+            this.field_73064_N = new LongObjectHashMap<Set<NextTickListEntry>>(); // CraftBukkit
         }
 
         if (this.pendingTickListEntries == null)
@@ -272,6 +274,7 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
         }
 
         // CraftBukkit end
+        this.getWorld().processChunkGC();   // Spigot
         this.theProfiler.endStartSection("chunkSource");
         this.chunkProvider.unload100OldestChunks();
         int var4 = this.calculateSkylightSubtracted(1.0F);
@@ -411,60 +414,70 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
      */
     protected void tickBlocksAndAmbiance()
     {
+        // Spigot start
+        this.aggregateTicks--;
+
+        if (this.aggregateTicks != 0)
+        {
+            return;
+        }
+
+        aggregateTicks = this.getWorld().aggregateTicks;
+        // Spigot end
         super.tickBlocksAndAmbiance();
         int var1 = 0;
         int var2 = 0;
         // CraftBukkit start
-        // Iterator iterator = this.chunkTickList.iterator();
+        // Iterator iterator = this.chunkTickList.iterator(); // CraftBukkit
 
-        for (long chunkCoord : this.activeChunkSet.popAll())
+        // CraftBukkit start
+        // Spigot start
+        for (TLongShortIterator iter = activeChunkSet.iterator(); iter.hasNext();)
         {
-            int chunkX = LongHash.msw(chunkCoord);
-            int chunkZ = LongHash.lsw(chunkCoord);
+            iter.advance();
+            long chunkCoord = iter.key();
+            int chunkX = World.keyToX(chunkCoord);
+            int chunkZ = World.keyToZ(chunkCoord);
+
+            // If unloaded, or in procedd of being unloaded, drop it
+            if ((!this.chunkExists(chunkX,  chunkZ)) || (this.theChunkProviderServer.chunksToUnload.contains(chunkX, chunkZ)))
+            {
+                iter.remove();
+                continue;
+            }
+
+            int players = iter.value();
+            // Spigot end
             // ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
-            int k = chunkX * 16;
-            int l = chunkZ * 16;
+            int var3 = chunkX * 16;
+            int var4 = chunkZ * 16;
             this.theProfiler.startSection("getChunk");
-            Chunk chunk = this.getChunkFromChunkCoords(chunkX, chunkZ);
+            Chunk var5 = this.getChunkFromChunkCoords(chunkX, chunkZ);
             // CraftBukkit end
-            this.moodSoundAndLightCheck(k, l, chunk);
+            this.moodSoundAndLightCheck(var3, var4, var5);
             this.theProfiler.endStartSection("tickChunk");
-            chunk.updateSkylight();
+            var5.updateSkylight();
             this.theProfiler.endStartSection("thunder");
-            int var3;
-            int var4;
-            int var5;
             int var6;
-
-            if (this.rand.nextInt(100000) == 0 && this.isRaining() && this.isThundering())
-            {
-                this.updateLCG = this.updateLCG * 3 + 1013904223;
-                var3 = this.updateLCG >> 2;
-                var4 = k + (var3 & 15);
-                var5 = l + (var3 >> 8 & 15);
-                var6 = this.getPrecipitationHeight(var4, var5);
-
-                if (this.canLightningStrikeAt(var4, var6, var5))
-                {
-                    this.addWeatherEffect(new EntityLightningBolt(this, (double) var4, (double) var6, (double) var5));
-                }
-            }
-
-            this.theProfiler.endStartSection("iceandsnow");
             int var7;
+            int var8;
+            int var9;
+            // Spigot - remove lightning code
+            this.theProfiler.endStartSection("iceandsnow");
+            int var10;
 
             if (this.rand.nextInt(16) == 0)
             {
                 this.updateLCG = this.updateLCG * 3 + 1013904223;
-                var3 = this.updateLCG >> 2;
-                var4 = var3 & 15;
-                var5 = var3 >> 8 & 15;
-                var6 = this.getPrecipitationHeight(var4 + k, var5 + l);
+                var6 = this.updateLCG >> 2;
+                var7 = var6 & 15;
+                var8 = var6 >> 8 & 15;
+                var9 = this.getPrecipitationHeight(var7 + var3, var8 + var4);
 
-                if (this.isBlockFreezableNaturally(var4 + k, var6 - 1, var5 + l))
+                if (this.isBlockFreezableNaturally(var7 + var3, var9 - 1, var8 + var4))
                 {
                     // CraftBukkit start
-                    BlockState blockState = this.getWorld().getBlockAt(var4 + k, var6 - 1, var5 + l).getState();
+                    BlockState blockState = this.getWorld().getBlockAt(var7 + var3, var9 - 1, var8 + var4).getState();
                     blockState.setTypeId(Block.ice.blockID);
                     BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
                     this.getServer().getPluginManager().callEvent(iceBlockForm);
@@ -477,10 +490,10 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
                     // CraftBukkit end
                 }
 
-                if (this.isRaining() && this.canSnowAt(var4 + k, var6, var5 + l))
+                if (this.isRaining() && this.canSnowAt(var7 + var3, var9, var8 + var4))
                 {
                     // CraftBukkit start
-                    BlockState blockState = this.getWorld().getBlockAt(var4 + k, var6, var5 + l).getState();
+                    BlockState blockState = this.getWorld().getBlockAt(var7 + var3, var9, var8 + var4).getState();
                     blockState.setTypeId(Block.snow.blockID);
                     BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
                     this.getServer().getPluginManager().callEvent(snow);
@@ -495,45 +508,58 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
 
                 if (this.isRaining())
                 {
-                    BiomeGenBase var8 = this.getBiomeGenForCoords(var4 + k, var5 + l);
+                    BiomeGenBase var11 = this.getBiomeGenForCoords(var7 + var3, var8 + var4);
 
-                    if (var8.canSpawnLightningBolt())
+                    if (var11.canSpawnLightningBolt())
                     {
-                        var7 = this.getBlockId(var4 + k, var6 - 1, var5 + l);
+                        var10 = this.getBlockId(var7 + var3, var9 - 1, var8 + var4);
 
-                        if (var7 != 0)
+                        if (var10 != 0)
                         {
-                            Block.blocksList[var7].fillWithRain(this, var4 + k, var6 - 1, var5 + l);
+                            Block.blocksList[var10].fillWithRain(this, var7 + var3, var9 - 1, var8 + var4);
                         }
                     }
                 }
             }
 
             this.theProfiler.endStartSection("tickTiles");
-            ExtendedBlockStorage[] var9 = chunk.getBlockStorageArray();
-            var4 = var9.length;
+            ExtendedBlockStorage[] var13 = var5.getBlockStorageArray();
+            var7 = var13.length;
 
-            for (var5 = 0; var5 < var4; ++var5)
+            for (var8 = 0; var8 < var7; ++var8)
             {
-                ExtendedBlockStorage var10 = var9[var5];
+                ExtendedBlockStorage var12 = var13[var8];
 
-                if (var10 != null && var10.getNeedsRandomTick())
+                if (var12 != null && var12.getNeedsRandomTick())
                 {
-                    for (int var11 = 0; var11 < 3; ++var11)
+                    for (int var19 = 0; var19 < 3; ++var19)
                     {
                         this.updateLCG = this.updateLCG * 3 + 1013904223;
-                        var7 = this.updateLCG >> 2;
-                        int var13 = var7 & 15;
-                        int var12 = var7 >> 8 & 15;
-                        int var19 = var7 >> 16 & 15;
-                        int var21 = var10.getExtBlockID(var13, var19, var12);
+                        var10 = this.updateLCG >> 2;
+                        int var21 = var10 & 15;
+                        int var20 = var10 >> 8 & 15;
+                        int var14 = var10 >> 16 & 15;
+                        int var15 = var12.getExtBlockID(var21, var14, var20);
                         ++var2;
-                        Block var20 = Block.blocksList[var21];
+                        Block var16 = Block.blocksList[var15];
 
-                        if (var20 != null && var20.getTickRandomly())
+                        if (var16 != null && var16.getTickRandomly())
                         {
                             ++var1;
-                            var20.updateTick(this, var13 + k, var19 + var10.getYLocation(), var12 + l, this.rand);
+
+                            // Spigot start
+                            if (players < 1)
+                            {
+                                //grow fast if no players are in this chunk
+                                this.growthOdds = modifiedOdds;
+                            }
+                            else
+                            {
+                                this.growthOdds = 100;
+                            }
+
+                            // Spigot end
+                            var16.updateTick(this, var21 + var3, var14 + var12.getYLocation(), var20 + var4, this.rand);
                         }
                     }
                 }
@@ -584,11 +610,11 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
                 var7.func_82753_a(par6);
             }
 
-            if (!this.field_73064_N.contains(var7))
-            {
-                this.field_73064_N.add(var7);
-                this.pendingTickListEntries.add(var7);
-            }
+            // if (!this.L.contains(nextticklistentry)) {
+            // this.L.add(nextticklistentry);
+            // this.M.add(nextticklistentry);
+            // }
+            addNextTickIfNeeded(var7); // CraftBukkit
         }
     }
 
@@ -604,11 +630,11 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
             var6.setScheduledTime((long)par5 + this.worldInfo.getWorldTotalTime());
         }
 
-        if (!this.field_73064_N.contains(var6))
-        {
-            this.field_73064_N.add(var6);
-            this.pendingTickListEntries.add(var6);
-        }
+        //if (!this.L.contains(nextticklistentry)) {
+        //    this.L.add(nextticklistentry);
+        //    this.M.add(nextticklistentry);
+        //}
+        addNextTickIfNeeded(var6); // CraftBukkit
     }
 
     /**
@@ -646,108 +672,107 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
     {
         int var2 = this.pendingTickListEntries.size();
 
-        if (var2 != this.field_73064_N.size())
-        {
-            throw new IllegalStateException("TickNextTick list out of synch");
-        }
-        else
+        //if (i != this.L.size()) { // Spigot
+        //    throw new IllegalStateException("TickNextTick list out of synch"); // Spigot
+        //} else { // Spigot
+        if (var2 > 1000)
         {
-            if (var2 > 1000)
+            // CraftBukkit start - if the server has too much to process over time, try to alleviate that
+            if (var2 > 20 * 1000)
             {
-                // CraftBukkit start - if the server has too much to process over time, try to alleviate that
-                if (var2 > 20 * 1000)
-                {
-                    var2 = var2 / 20;
-                }
-                else
-                {
-                    var2 = 1000;
-                }
-
-                // CraftBukkit end
+                var2 = var2 / 20;
+            }
+            else
+            {
+                var2 = 1000;
             }
 
-            for (int var3 = 0; var3 < var2; ++var3)
+            // CraftBukkit end
+        }
+
+        for (int var3 = 0; var3 < var2; ++var3)
+        {
+            NextTickListEntry var4 = (NextTickListEntry) this.pendingTickListEntries.first();
+
+            if (!par1 && var4.scheduledTime > this.worldInfo.getWorldTotalTime())
             {
-                NextTickListEntry var4 = (NextTickListEntry)this.pendingTickListEntries.first();
+                break;
+            }
 
-                if (!par1 && var4.scheduledTime > this.worldInfo.getWorldTotalTime())
-                {
-                    break;
-                }
+            // Spigot start
+            //this.M.remove(nextticklistentry);
+            //this.L.remove(nextticklistentry);
+            this.removeNextTickIfNeeded(var4);
+            // Spigot end
+            byte var5 = 8;
 
-                this.pendingTickListEntries.remove(var4);
-                this.field_73064_N.remove(var4);
-                byte var5 = 8;
+            if (this.checkChunksExist(var4.xCoord - var5, var4.yCoord - var5, var4.zCoord - var5, var4.xCoord + var5, var4.yCoord + var5, var4.zCoord + var5))
+            {
+                int var6 = this.getBlockId(var4.xCoord, var4.yCoord, var4.zCoord);
 
-                if (this.checkChunksExist(var4.xCoord - var5, var4.yCoord - var5, var4.zCoord - var5, var4.xCoord + var5, var4.yCoord + var5, var4.zCoord + var5))
+                if (var6 == var4.blockID && var6 > 0)
                 {
-                    int var6 = this.getBlockId(var4.xCoord, var4.yCoord, var4.zCoord);
-
-                    if (var6 == var4.blockID && var6 > 0)
+                    try
+                    {
+                        Block.blocksList[var6].updateTick(this, var4.xCoord, var4.yCoord, var4.zCoord, this.rand);
+                    }
+                    catch (Throwable var13)
                     {
+                        CrashReport var8 = CrashReport.makeCrashReport(var13, "Exception while ticking a block");
+                        CrashReportCategory var9 = var8.makeCategory("Block being ticked");
+                        int var10;
+
                         try
                         {
-                            Block.blocksList[var6].updateTick(this, var4.xCoord, var4.yCoord, var4.zCoord, this.rand);
+                            var10 = this.getBlockMetadata(var4.xCoord, var4.yCoord, var4.zCoord);
                         }
-                        catch (Throwable var13)
+                        catch (Throwable var12)
                         {
-                            CrashReport var8 = CrashReport.makeCrashReport(var13, "Exception while ticking a block");
-                            CrashReportCategory var9 = var8.makeCategory("Block being ticked");
-                            int var10;
-
-                            try
-                            {
-                                var10 = this.getBlockMetadata(var4.xCoord, var4.yCoord, var4.zCoord);
-                            }
-                            catch (Throwable var12)
-                            {
-                                var10 = -1;
-                            }
-
-                            CrashReportCategory.func_85068_a(var9, var4.xCoord, var4.yCoord, var4.zCoord, var6, var10);
-                            throw new ReportedException(var8);
+                            var10 = -1;
                         }
+
+                        CrashReportCategory.func_85068_a(var9, var4.xCoord, var4.yCoord, var4.zCoord, var6, var10);
+                        throw new ReportedException(var8);
                     }
                 }
             }
-
-            return !this.pendingTickListEntries.isEmpty();
         }
+
+        return !this.pendingTickListEntries.isEmpty();
+        // } // Spigot
     }
 
     public List getPendingBlockUpdates(Chunk par1Chunk, boolean par2)
     {
-        ArrayList var3 = null;
-        ChunkCoordIntPair var4 = par1Chunk.getChunkCoordIntPair();
-        int var5 = var4.chunkXPos << 4;
-        int var6 = var5 + 16;
-        int var7 = var4.chunkZPos << 4;
-        int var8 = var7 + 16;
-        Iterator var9 = this.pendingTickListEntries.iterator();
-
-        while (var9.hasNext())
-        {
-            NextTickListEntry var10 = (NextTickListEntry)var9.next();
-
-            if (var10.xCoord >= var5 && var10.xCoord < var6 && var10.zCoord >= var7 && var10.zCoord < var8)
-            {
-                if (par2)
-                {
-                    this.field_73064_N.remove(var10);
-                    var9.remove();
+        return this.getNextTickEntriesForChunk(par1Chunk, par2); // Spigot
+        /* Spigot start
+        ArrayList arraylist = null;
+        ChunkCoordIntPair chunkcoordintpair = chunk.l();
+        int i = chunkcoordintpair.x << 4;
+        int j = i + 16;
+        int k = chunkcoordintpair.z << 4;
+        int l = k + 16;
+        Iterator iterator = this.M.iterator();
+
+        while (iterator.hasNext()) {
+            NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
+
+            if (nextticklistentry.a >= i && nextticklistentry.a < j && nextticklistentry.c >= k && nextticklistentry.c < l) {
+                if (flag) {
+                    this.L.remove(nextticklistentry);
+                    iterator.remove();
                 }
 
-                if (var3 == null)
-                {
-                    var3 = new ArrayList();
+                if (arraylist == null) {
+                    arraylist = new ArrayList();
                 }
 
-                var3.add(var10);
+                arraylist.add(nextticklistentry);
             }
         }
 
-        return var3;
+        return arraylist;
+        // Spigot end */
     }
 
     /**
@@ -860,7 +885,7 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
 
         if (this.field_73064_N == null)
         {
-            this.field_73064_N = new HashSet();
+            this.field_73064_N = new LongObjectHashMap<Set<NextTickListEntry>>();
         }
 
         if (this.pendingTickListEntries == null)
@@ -1247,4 +1272,68 @@ public class WorldServer extends World implements org.bukkit.BlockChangeDelegate
     {
         return this.field_85177_Q;
     }
+
+    // Spigot start
+    private void addNextTickIfNeeded(NextTickListEntry ent)
+    {
+        long coord = LongHash.toLong(ent.xCoord >> 4, ent.zCoord >> 4);
+        Set<NextTickListEntry> chunkset = field_73064_N.get(coord);
+
+        if (chunkset == null)
+        {
+            chunkset = new HashSet<NextTickListEntry>();
+            field_73064_N.put(coord, chunkset);
+        }
+        else if (chunkset.contains(ent))
+        {
+            return;
+        }
+
+        chunkset.add(ent);
+        pendingTickListEntries.add(ent);
+    }
+
+    private void removeNextTickIfNeeded(NextTickListEntry ent)
+    {
+        long coord = LongHash.toLong(ent.xCoord >> 4, ent.zCoord >> 4);
+        Set<NextTickListEntry> chunkset = field_73064_N.get(coord);
+
+        if (chunkset == null)
+        {
+            return;
+        }
+
+        if (chunkset.remove(ent))
+        {
+            pendingTickListEntries.remove(ent);
+
+            if (chunkset.isEmpty())
+            {
+                field_73064_N.remove(coord);
+            }
+        }
+    }
+
+    private List<NextTickListEntry> getNextTickEntriesForChunk(Chunk chunk, boolean remove)
+    {
+        long coord = LongHash.toLong(chunk.xPosition, chunk.zPosition);
+        Set<NextTickListEntry> chunkset = field_73064_N.get(coord);
+
+        if (chunkset == null)
+        {
+            return null;
+        }
+
+        List<NextTickListEntry> list = new ArrayList<NextTickListEntry>(chunkset);
+
+        if (remove)
+        {
+            field_73064_N.remove(coord);
+            pendingTickListEntries.removeAll(list);
+            chunkset.clear();
+        }
+
+        return list;
+    }
+    // Spigot end
 }
diff --git a/src/minecraft/net/minecraft/world/chunk/storage/AnvilChunkLoader.java b/src/minecraft/net/minecraft/world/chunk/storage/AnvilChunkLoader.java
index 58b2ec0..b17cc68 100644
--- a/src/minecraft/net/minecraft/world/chunk/storage/AnvilChunkLoader.java
+++ b/src/minecraft/net/minecraft/world/chunk/storage/AnvilChunkLoader.java
@@ -27,8 +27,7 @@ import net.minecraft.world.storage.ThreadedFileIOBase;
 
 public class AnvilChunkLoader implements IThreadedFileIO, IChunkLoader
 {
-    private List chunksToRemove = new ArrayList();
-    private Set pendingAnvilChunksCoordinates = new HashSet();
+    private java.util.LinkedHashMap<ChunkCoordIntPair, AnvilChunkLoaderPending> pendingSaves = new java.util.LinkedHashMap<ChunkCoordIntPair, AnvilChunkLoaderPending>(); // Spigot
     private Object syncLockObject = new Object();
 
     /** Save directory for chunks using the Anvil format */
@@ -46,18 +45,14 @@ public class AnvilChunkLoader implements IThreadedFileIO, IChunkLoader
 
         synchronized (this.syncLockObject)
         {
-            if (this.pendingAnvilChunksCoordinates.contains(chunkcoordintpair))
+            // Spigot start
+            if (pendingSaves.containsKey(chunkcoordintpair))
             {
-                for (int k = 0; k < this.chunksToRemove.size(); ++k)
-                {
-                    if (((AnvilChunkLoaderPending) this.chunksToRemove.get(k)).chunkCoordinate.equals(chunkcoordintpair))
-                    {
-                        return true;
-                    }
-                }
+                return true;
             }
         }
 
+        // Spigot end
         return RegionFileCache.createOrLoadRegionFile(this.chunkSaveLocation, i, j).chunkExists(i & 31, j & 31);
     }
     // CraftBukkit end
@@ -87,17 +82,24 @@ public class AnvilChunkLoader implements IThreadedFileIO, IChunkLoader
 
         synchronized (this.syncLockObject)
         {
-            if (this.pendingAnvilChunksCoordinates.contains(chunkcoordintpair))
+            // Spigot start
+            AnvilChunkLoaderPending pendingchunktosave = pendingSaves.get(chunkcoordintpair);
+
+            if (pendingchunktosave != null)
             {
-                for (int k = 0; k < this.chunksToRemove.size(); ++k)
-                {
-                    if (((AnvilChunkLoaderPending) this.chunksToRemove.get(k)).chunkCoordinate.equals(chunkcoordintpair))
-                    {
-                        nbttagcompound = ((AnvilChunkLoaderPending) this.chunksToRemove.get(k)).nbtTags;
+                nbttagcompound = pendingchunktosave.nbtTags;
+            }
+
+            /*
+            if (this.b.contains(chunkcoordintpair)) {
+                for (int k = 0; k < this.a.size(); ++k) {
+                    if (((PendingChunkToSave) this.a.get(k)).a.equals(chunkcoordintpair)) {
+                        nbttagcompound = ((PendingChunkToSave) this.a.get(k)).b;
                         break;
                     }
                 }
             }
+            */// Spigot end
         }
 
         if (nbttagcompound == null)
@@ -192,20 +194,25 @@ public class AnvilChunkLoader implements IThreadedFileIO, IChunkLoader
 
         synchronized (this.syncLockObject)
         {
-            if (this.pendingAnvilChunksCoordinates.contains(par1ChunkCoordIntPair))
+            // Spigot start
+            if (this.pendingSaves.put(par1ChunkCoordIntPair, new AnvilChunkLoaderPending(par1ChunkCoordIntPair, par2NBTTagCompound)) != null)
             {
-                for (int var4 = 0; var4 < this.chunksToRemove.size(); ++var4)
-                {
-                    if (((AnvilChunkLoaderPending)this.chunksToRemove.get(var4)).chunkCoordinate.equals(par1ChunkCoordIntPair))
-                    {
-                        this.chunksToRemove.set(var4, new AnvilChunkLoaderPending(par1ChunkCoordIntPair, par2NBTTagCompound));
+                return;
+            }
+
+            /*
+            if (this.b.contains(chunkcoordintpair)) {
+                for (int i = 0; i < this.a.size(); ++i) {
+                    if (((PendingChunkToSave) this.a.get(i)).a.equals(chunkcoordintpair)) {
+                        this.a.set(i, new PendingChunkToSave(chunkcoordintpair, nbttagcompound));
                         return;
                     }
                 }
             }
 
-            this.chunksToRemove.add(new AnvilChunkLoaderPending(par1ChunkCoordIntPair, par2NBTTagCompound));
-            this.pendingAnvilChunksCoordinates.add(par1ChunkCoordIntPair);
+            this.a.add(new PendingChunkToSave(chunkcoordintpair, nbttagcompound));
+            this.b.add(chunkcoordintpair);
+            */// Spigot end
             ThreadedFileIOBase.threadedIOInstance.queueIO(this);
         }
     }
@@ -220,13 +227,22 @@ public class AnvilChunkLoader implements IThreadedFileIO, IChunkLoader
 
         synchronized (this.syncLockObject)
         {
-            if (this.chunksToRemove.isEmpty())
+            // Spigot start
+            if (this.pendingSaves.isEmpty())
             {
                 return false;
             }
 
-            var1 = (AnvilChunkLoaderPending)this.chunksToRemove.remove(0);
-            this.pendingAnvilChunksCoordinates.remove(var1.chunkCoordinate);
+            var1 = this.pendingSaves.values().iterator().next();
+            this.pendingSaves.remove(var1.chunkCoordinate);
+            /*
+            if (this.a.isEmpty()) {
+                return false;
+            }
+
+            pendingchunktosave = (PendingChunkToSave) this.a.remove(0);
+            this.b.remove(pendingchunktosave.a);
+            */// Spigot end
         }
 
         if (var1 != null)
diff --git a/src/minecraft/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java b/src/minecraft/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java
index 641507a..94f71ff 100644
--- a/src/minecraft/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java
+++ b/src/minecraft/net/minecraft/world/chunk/storage/ExtendedBlockStorage.java
@@ -385,7 +385,7 @@ public class ExtendedBlockStorage
      */
     public void setBlockLSBArray(byte[] par1ArrayOfByte)
     {
-        this.blockLSBArray = par1ArrayOfByte;
+        this.blockLSBArray = validateByteArray(par1ArrayOfByte); // Spigot - validate
     }
 
     /**
@@ -411,7 +411,7 @@ public class ExtendedBlockStorage
         }
 
         // CraftBukkit end
-        this.blockMSBArray = par1NibbleArray;
+        this.blockMSBArray = validateNibbleArray(par1NibbleArray); // Spigot - validate
     }
 
     /**
@@ -419,7 +419,7 @@ public class ExtendedBlockStorage
      */
     public void setBlockMetadataArray(NibbleArray par1NibbleArray)
     {
-        this.blockMetadataArray = par1NibbleArray;
+        this.blockMetadataArray = validateNibbleArray(par1NibbleArray); // Spigot - validate
     }
 
     /**
@@ -427,7 +427,7 @@ public class ExtendedBlockStorage
      */
     public void setBlocklightArray(NibbleArray par1NibbleArray)
     {
-        this.blocklightArray = par1NibbleArray;
+        this.blocklightArray = validateNibbleArray(par1NibbleArray); // Spigot - validate
     }
 
     /**
@@ -435,6 +435,32 @@ public class ExtendedBlockStorage
      */
     public void setSkylightArray(NibbleArray par1NibbleArray)
     {
-        this.skylightArray = par1NibbleArray;
+        this.skylightArray = validateNibbleArray(par1NibbleArray); // Spigot - validate
     }
+
+    // Spigot start - validate/correct nibble array
+    private static final NibbleArray validateNibbleArray(NibbleArray na)
+    {
+        if ((na != null) && (na.data.length < 2048))
+        {
+            NibbleArray newna = new NibbleArray(4096, 4);
+            System.arraycopy(na.data, 0, newna.data, 0, na.data.length);
+            na = newna;
+        }
+
+        return na;
+    }
+    // Validate/correct byte array
+    private static final byte[] validateByteArray(byte[] ba)
+    {
+        if ((ba != null) && (ba.length < 4096))
+        {
+            byte[] newba = new byte[4096];
+            System.arraycopy(ba,  0,  newba,  0,  ba.length);
+            ba = newba;
+        }
+
+        return ba;
+    }
+    // Spigot end
 }
diff --git a/src/minecraft/org/bukkit/craftbukkit/CraftServer.java b/src/minecraft/org/bukkit/craftbukkit/CraftServer.java
index cc11e7e..35ecd03 100644
--- a/src/minecraft/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/minecraft/org/bukkit/craftbukkit/CraftServer.java
@@ -116,7 +116,7 @@ public final class CraftServer implements Server {
     protected final net.minecraft.server.MinecraftServer/*was:MinecraftServer*/ console;
     protected final net.minecraft.server.dedicated.DedicatedPlayerList/*was:DedicatedPlayerList*/ playerList;
     private final Map<String, World> worlds = new LinkedHashMap<String, World>();
-    private YamlConfiguration configuration;
+    protected YamlConfiguration configuration; // Spigot private -> protected
     private final Yaml yaml = new Yaml(new SafeConstructor());
     private final Map<String, OfflinePlayer> offlinePlayers = new MapMaker().softValues().makeMap();
     private final AutoUpdater updater;
@@ -136,6 +136,14 @@ public final class CraftServer implements Server {
     private final class BooleanWrapper {
         private boolean value = true;
     }
+    // Spigot start
+    public String whitelistMessage = "You are not white-listed on this server!";
+    public String stopMessage = "Server restarting. Brb";
+    public boolean logCommands = true;
+    public boolean ipFilter = false;
+    public boolean commandComplete = true;
+    public List<String> spamGuardExclusions;
+    // Spigot end
 
     static {
         ConfigurationSerialization.registerClass(CraftOfflinePlayer.class);
@@ -178,12 +186,37 @@ public final class CraftServer implements Server {
         chunkGCLoadThresh = configuration.getInt("chunk-gc.load-threshold");
 
         updater = new AutoUpdater(new BukkitDLUpdaterService(configuration.getString("auto-updater.host")), getLogger(), configuration.getString("auto-updater.preferred-channel"));
-        updater.setEnabled(configuration.getBoolean("auto-updater.enabled"));
+        updater.setEnabled(false);
         updater.setSuggestChannels(configuration.getBoolean("auto-updater.suggest-channels"));
         updater.getOnBroken().addAll(configuration.getStringList("auto-updater.on-broken"));
         updater.getOnUpdate().addAll(configuration.getStringList("auto-updater.on-update"));
         updater.check(serverVersion);
 
+        // Spigot start
+        commandMap.register("bukkit", new org.bukkit.craftbukkit.command.RestartCommand("restart"));
+        commandMap.register("bukkit", new org.bukkit.craftbukkit.command.TicksPerSecondCommand("tps"));
+
+        org.bukkit.craftbukkit.util.WatchdogThread.startThread(configuration.getInt("settings.timeout-time", 180), configuration.getBoolean("settings.restart-on-crash", false));
+
+        whitelistMessage = configuration.getString("settings.whitelist-message", whitelistMessage);
+        stopMessage = configuration.getString("settings.stop-message", stopMessage);
+        logCommands = configuration.getBoolean("settings.log-commands", true);
+        ipFilter = configuration.getBoolean("settings.filter-unsafe-ips", false);
+        commandComplete = configuration.getBoolean("settings.command-complete", true);
+        spamGuardExclusions = configuration.getStringList("settings.spam-exclusions");
+
+        org.bukkit.craftbukkit.util.LightningSimulator.configure(configuration);
+
+        try {
+            configuration.save(getConfigFile());
+        } catch (IOException e) {
+        }
+        try {
+            new org.bukkit.craftbukkit.util.Metrics().start();
+        } catch (IOException e) {
+            getLogger().log(Level.SEVERE, "Could not start metrics", e);
+        }
+        // Spigot end
         loadPlugins();
         enablePlugins(PluginLoadOrder.STARTUP);
     }
@@ -192,7 +225,7 @@ public final class CraftServer implements Server {
         return (File) console.options.valueOf("bukkit-settings");
     }
 
-    private void saveConfig() {
+    public void saveConfig() { // Spigot private -> public
         try {
             configuration.save(getConfigFile());
         } catch (IOException ex) {
@@ -1039,11 +1072,8 @@ public final class CraftServer implements Server {
         return count;
     }
 
+    // Spigot start
     public OfflinePlayer getOfflinePlayer(String name) {
-        return getOfflinePlayer(name, true);
-    }
-
-    public OfflinePlayer getOfflinePlayer(String name, boolean search) {
         OfflinePlayer result = getPlayerExact(name);
         String lname = name.toLowerCase();
 
@@ -1051,17 +1081,7 @@ public final class CraftServer implements Server {
             result = offlinePlayers.get(lname);
 
             if (result == null) {
-                if (search) {
-                    net.minecraft.world.storage.SaveHandler/*was:WorldNBTStorage*/ storage = (net.minecraft.world.storage.SaveHandler/*was:WorldNBTStorage*/) console.worlds.get(0).getSaveHandler/*was:getDataManager*/();
-                    for (String dat : storage.getPlayerDir().list(new DatFileFilter())) {
-                        String datName = dat.substring(0, dat.length() - 4);
-                        if (datName.equalsIgnoreCase(name)) {
-                            name = datName;
-                            break;
-                        }
-                    }
-                }
-
+                // Spigot end
                 result = new CraftOfflinePlayer(this, name);
                 offlinePlayers.put(lname, result);
             }
@@ -1199,7 +1219,7 @@ public final class CraftServer implements Server {
         Set<OfflinePlayer> players = new HashSet<OfflinePlayer>();
 
         for (String file : files) {
-            players.add(getOfflinePlayer(file.substring(0, file.length() - 4), false));
+            players.add(getOfflinePlayer(file.substring(0, file.length() - 4))); // Spigot
         }
         players.addAll(Arrays.asList(getOnlinePlayers()));
 
@@ -1305,7 +1325,7 @@ public final class CraftServer implements Server {
     public List<String> tabCompleteCommand(Player player, String message) {
         List<String> completions = null;
         try {
-            completions = getCommandMap().tabComplete(player, message.substring(1));
+            completions = (commandComplete) ? getCommandMap().tabComplete(player, message.substring(1)) : null; // Spigot
         } catch (CommandException ex) {
             player.sendMessage(ChatColor.RED + "An internal error occurred while attempting to tab-complete this command");
             getLogger().log(Level.SEVERE, "Exception when " + player.getName() + " attempted to tab complete " + message, ex);
@@ -1341,4 +1361,52 @@ public final class CraftServer implements Server {
     public CraftItemFactory getItemFactory() {
         return CraftItemFactory.instance();
     }
+
+    // Spigot start
+    public void restart() {
+        try {
+            String startupScript = configuration.getString("settings.restart-script-location", "");
+            File file = new File(startupScript);
+            if (file.isFile()) {
+                System.out.println("Attempting to restart with " + startupScript);
+
+                // Kick all players
+                for (Player p : this.getOnlinePlayers()) {
+                   ((org.bukkit.craftbukkit.entity.CraftPlayer) p).kickPlayer("Server is restarting", true);
+                }
+                // Give the socket a chance to send the packets
+                try {
+                    Thread.sleep(100);
+                } catch (InterruptedException ex) {
+                }
+                // Close the socket so we can rebind with the new process
+                this.getServer().getNetworkThread/*was:ae*/().stopListening/*was:a*/();
+
+                // Give time for it to kick in
+                try {
+                    Thread.sleep(100);
+                } catch (InterruptedException ex) {
+                }
+
+                // Actually shutdown
+                try {
+                    this.getServer().stopServer/*was:stop*/();
+                } catch (Throwable t) {
+                }
+
+                String os = System.getProperty("os.name").toLowerCase();
+                if (os.contains("win")) {
+                    Runtime.getRuntime().exec("cmd /c start " + file.getPath());
+                } else {
+                    Runtime.getRuntime().exec(file.getPath());
+                }
+                System.exit(0);
+            } else {
+                System.out.println("Startup script '" + startupScript + "' does not exist!");
+            }
+        } catch (Exception ex) {
+            ex.printStackTrace();
+        }
+    }
+    // Spigot end
 }
diff --git a/src/minecraft/org/bukkit/craftbukkit/CraftWorld.java b/src/minecraft/org/bukkit/craftbukkit/CraftWorld.java
index c64b111..6093952 100644
--- a/src/minecraft/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/minecraft/org/bukkit/craftbukkit/CraftWorld.java
@@ -72,7 +72,81 @@ public class CraftWorld implements World {
         if (server.chunkGCPeriod > 0) {
             chunkGCTickCount = rand.nextInt(server.chunkGCPeriod);
         }
-    }
+        // Spigot Start
+        org.bukkit.configuration.file.YamlConfiguration configuration = server.configuration;
+        String name;
+        if (world.worldInfo/*was:worldData*/ == null || world.worldInfo/*was:worldData*/.getWorldName/*was:getName*/() == null) {
+            name = "default";
+        } else {
+            name = world.worldInfo/*was:worldData*/.getWorldName/*was:getName*/().replaceAll(" ", "_");
+        }
+
+        //load defaults first
+        growthPerTick = configuration.getInt("world-settings.default.growth-chunks-per-tick", growthPerTick);
+        itemMergeRadius = configuration.getDouble("world-settings.default.item-merge-radius", itemMergeRadius);
+        expMergeRadius = configuration.getDouble("world-settings.default.exp-merge-radius", expMergeRadius);
+        randomLightingUpdates = configuration.getBoolean("world-settings.default.random-light-updates", randomLightingUpdates);
+        mobSpawnRange = configuration.getInt("world-settings.default.mob-spawn-range", mobSpawnRange);
+        aggregateTicks = Math.max(1, configuration.getInt("world-settings.default.aggregate-chunkticks", aggregateTicks));
+
+        wheatGrowthModifier = configuration.getInt("world-settings.default.wheat-growth-modifier", wheatGrowthModifier);
+        cactusGrowthModifier = configuration.getInt("world-settings.default.cactus-growth-modifier", cactusGrowthModifier);
+        melonGrowthModifier = configuration.getInt("world-settings.default.melon-growth-modifier", melonGrowthModifier);
+        pumpkinGrowthModifier = configuration.getInt("world-settings.default.pumpkin-growth-modifier", pumpkinGrowthModifier);
+        sugarGrowthModifier = configuration.getInt("world-settings.default.sugar-growth-modifier", sugarGrowthModifier);
+        treeGrowthModifier = configuration.getInt("world-settings.default.tree-growth-modifier", treeGrowthModifier);
+        mushroomGrowthModifier = configuration.getInt("world-settings.default.mushroom-growth-modifier", mushroomGrowthModifier);
+
+        //override defaults with world specific, if they exist
+        growthPerTick = configuration.getInt("world-settings." + name + ".growth-chunks-per-tick", growthPerTick);
+        itemMergeRadius = configuration.getDouble("world-settings." + name + ".item-merge-radius", itemMergeRadius);
+      expMergeRadius = configuration.getDouble("world-settings." + name + ".exp-merge-radius", expMergeRadius);
+        randomLightingUpdates = configuration.getBoolean("world-settings." + name + ".random-light-updates", randomLightingUpdates);
+        mobSpawnRange = configuration.getInt("world-settings." + name + ".mob-spawn-range", mobSpawnRange);
+        aggregateTicks = Math.max(1, configuration.getInt("world-settings." + name + ".aggregate-chunkticks", aggregateTicks));
+
+        wheatGrowthModifier = configuration.getInt("world-settings." + name + ".wheat-growth-modifier", wheatGrowthModifier);
+        cactusGrowthModifier = configuration.getInt("world-settings." + name + ".cactus-growth-modifier", cactusGrowthModifier);
+        melonGrowthModifier = configuration.getInt("world-settings." + name + ".melon-growth-modifier", melonGrowthModifier);
+        pumpkinGrowthModifier = configuration.getInt("world-settings." + name + ".pumpkin-growth-modifier", pumpkinGrowthModifier);
+        sugarGrowthModifier = configuration.getInt("world-settings." + name + ".sugar-growth-modifier", sugarGrowthModifier);
+        treeGrowthModifier = configuration.getInt("world-settings." + name + ".tree-growth-modifier", treeGrowthModifier);
+        mushroomGrowthModifier = configuration.getInt("world-settings." + name + ".mushroom-growth-modifier", mushroomGrowthModifier);
+
+        server.getLogger().info("-------------- Spigot ----------------");
+        server.getLogger().info("-------- World Settings For [" + name + "] --------");
+        server.getLogger().info("Growth Per Chunk: " + growthPerTick);
+        server.getLogger().info("Item Merge Radius: " + itemMergeRadius);
+        server.getLogger().info("Experience Merge Radius: " + expMergeRadius);
+        server.getLogger().info("Random Lighting Updates: " + randomLightingUpdates);
+        server.getLogger().info("Mob Spawn Range: " + mobSpawnRange);
+        server.getLogger().info("Aggregate Ticks: " + aggregateTicks);
+        server.getLogger().info("Wheat Growth Modifier: " + wheatGrowthModifier);
+        server.getLogger().info("Cactus Growth Modifier: " + cactusGrowthModifier);
+        server.getLogger().info("Melon Growth Modifier: " + melonGrowthModifier);
+        server.getLogger().info("Pumpkin Growth Modifier: " + pumpkinGrowthModifier);
+        server.getLogger().info("Sugar Growth Modifier: " + sugarGrowthModifier);
+        server.getLogger().info("Tree Growth Modifier: " + treeGrowthModifier);
+        server.getLogger().info("Mushroom Growth Modifier: " + mushroomGrowthModifier);
+        server.getLogger().info("-------------------------------------------------");
+        // Spigot end
+    }
+    // Spigot Start
+    public int growthPerTick = 650;
+    public double itemMergeRadius = 3;
+    public double expMergeRadius = 3;
+    public boolean randomLightingUpdates = false;
+    public int mobSpawnRange = 4;
+    public int aggregateTicks = 4;
+    //Crop growth rates:
+    public int wheatGrowthModifier = 100;
+    public int cactusGrowthModifier = 100;
+    public int melonGrowthModifier = 100;
+    public int pumpkinGrowthModifier = 100;
+    public int sugarGrowthModifier = 100;
+    public int treeGrowthModifier = 100;
+    public int mushroomGrowthModifier = 100;
+    // Spigot end
 
     public Block getBlockAt(int x, int y, int z) {
         return getChunkAt(x >> 4, z >> 4).getBlock(x & 0xF, y & 0xFF, z & 0xF);
diff --git a/src/minecraft/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java b/src/minecraft/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
index 2a88ba2..57cf87b 100644
--- a/src/minecraft/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
+++ b/src/minecraft/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
@@ -37,7 +37,7 @@ class ChunkIOProvider implements AsynchronousExecutor.CallBackProvider<QueuedChu
         // See if someone already loaded this chunk while we were working on it (API, etc)
         if (queuedChunk.provider.loadedChunkHashMap/*was:chunks*/.containsKey(queuedChunk.coords)) {
             // Make sure it isn't queued for unload, we need it
-            queuedChunk.provider.chunksToUnload/*was:unloadQueue*/.remove(queuedChunk.coords);
+            queuedChunk.provider.chunksToUnload/*was:unloadQueue*/.remove(x, z);
             return;
         }
 
diff --git a/src/minecraft/org/bukkit/craftbukkit/command/RestartCommand.java b/src/minecraft/org/bukkit/craftbukkit/command/RestartCommand.java
new file mode 100644
index 0000000..fba4b4a
--- /dev/null
+++ b/src/minecraft/org/bukkit/craftbukkit/command/RestartCommand.java
@@ -0,0 +1,24 @@
+package org.bukkit.craftbukkit.command;
+
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.craftbukkit.CraftServer;
+
+public class RestartCommand extends Command {
+    public RestartCommand(String name) {
+        super(name);
+        this.description = "Restarts the server";
+        this.usageMessage = "/restart";
+        this.setPermission("bukkit.command.restart");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+       ((CraftServer)Bukkit.getServer()).restart();
+
+        return true;
+    }
+}
\ No newline at end of file
diff --git a/src/minecraft/org/bukkit/craftbukkit/command/TicksPerSecondCommand.java b/src/minecraft/org/bukkit/craftbukkit/command/TicksPerSecondCommand.java
new file mode 100644
index 0000000..67fe760
--- /dev/null
+++ b/src/minecraft/org/bukkit/craftbukkit/command/TicksPerSecondCommand.java
@@ -0,0 +1,34 @@
+package org.bukkit.craftbukkit.command;
+
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+public class TicksPerSecondCommand extends Command {
+
+    public TicksPerSecondCommand(String name) {
+        super(name);
+        this.description = "Gets the current ticks per second for the server";
+        this.usageMessage = "/tps";
+        this.setPermission("bukkit.command.tps");
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        double tps = (double) Math.round(net.minecraft.server.MinecraftServer/*was:MinecraftServer*/.currentTPS * 10) / 10;
+        ChatColor color;
+        if (tps > 19.2D) {
+            color = ChatColor.GREEN;
+        } else if (tps > 17.4D) {
+            color = ChatColor.YELLOW;
+        } else {
+            color = ChatColor.RED;
+        }
+
+        sender.sendMessage(ChatColor.GOLD + "[TPS] " + color + tps);
+
+        return true;
+    }
+}
diff --git a/src/minecraft/org/bukkit/craftbukkit/entity/CraftPlayer.java b/src/minecraft/org/bukkit/craftbukkit/entity/CraftPlayer.java
index eedff22..d939738 100644
--- a/src/minecraft/org/bukkit/craftbukkit/entity/CraftPlayer.java
+++ b/src/minecraft/org/bukkit/craftbukkit/entity/CraftPlayer.java
@@ -211,10 +211,17 @@ public class CraftPlayer extends CraftHumanEntity implements Player {
     }
 
     public void kickPlayer(String message) {
+        // Spigot start
+        kickPlayer(message, false);
+    }
+
+    public void kickPlayer(String message, boolean async){
         if (getHandle().playerNetServerHandler/*was:playerConnection*/ == null) return;
+        if (!async && !Bukkit.isPrimaryThread()) throw new IllegalStateException("Cannot kick player from asynchronous thread!"); // Spigot
 
         getHandle().playerNetServerHandler/*was:playerConnection*/.kickPlayerFromServer/*was:disconnect*/(message == null ? "" : message);
     }
+    // Spigot end
 
     public void setCompassTarget(Location loc) {
         if (getHandle().playerNetServerHandler/*was:playerConnection*/ == null) return;
diff --git a/src/minecraft/org/bukkit/craftbukkit/updater/BukkitDLUpdaterService.java b/src/minecraft/org/bukkit/craftbukkit/updater/BukkitDLUpdaterService.java
index f027900..efc7889 100644
--- a/src/minecraft/org/bukkit/craftbukkit/updater/BukkitDLUpdaterService.java
+++ b/src/minecraft/org/bukkit/craftbukkit/updater/BukkitDLUpdaterService.java
@@ -1,6 +1,6 @@
 package org.bukkit.craftbukkit.updater;
 
-import com.google.gson.*;
+// import com.google.gson.*; // Spigot
 import java.io.IOException;
 import java.io.InputStreamReader;
 import java.io.UnsupportedEncodingException;
@@ -16,7 +16,7 @@ import java.util.logging.Logger;
 public class BukkitDLUpdaterService {
     private static final String API_PREFIX_ARTIFACT = "/api/1.0/downloads/projects/craftbukkit/view/";
     private static final String API_PREFIX_CHANNEL = "/api/1.0/downloads/channels/";
-    private static final DateDeserializer dateDeserializer = new DateDeserializer();
+    // private static final DateDeserializer dateDeserializer = new DateDeserializer(); // Spigot
     private final String host;
 
     public BukkitDLUpdaterService(String host) {
@@ -47,8 +47,11 @@ public class BukkitDLUpdaterService {
             URLConnection connection = url.openConnection();
             connection.setRequestProperty("User-Agent", getUserAgent());
             reader = new InputStreamReader(connection.getInputStream());
-            Gson gson = new GsonBuilder().registerTypeAdapter(Date.class, dateDeserializer).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();
-            return gson.fromJson(reader, ArtifactDetails.class);
+            // Spigot start
+            // Gson gson = new GsonBuilder().registerTypeAdapter(Date.class, dateDeserializer).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();
+            // return gson.fromJson(reader, ArtifactDetails.class);
+            // Spigot end
+            return null;
         } finally {
             if (reader != null) {
                 reader.close();
@@ -76,10 +79,13 @@ public class BukkitDLUpdaterService {
             URLConnection connection = url.openConnection();
             connection.setRequestProperty("User-Agent", getUserAgent());
             reader = new InputStreamReader(connection.getInputStream());
-            Gson gson = new GsonBuilder().registerTypeAdapter(Date.class, dateDeserializer).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();
-            ArtifactDetails.ChannelDetails fromJson = gson.fromJson(reader, ArtifactDetails.ChannelDetails.class);
+            // Spigot start
+            // Gson gson = new GsonBuilder().registerTypeAdapter(Date.class, dateDeserializer).setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();
+            // ArtifactDetails.ChannelDetails fromJson = gson.fromJson(reader, ArtifactDetails.ChannelDetails.class);
 
-            return fromJson;
+            //return fromJson;
+            // Spigot end
+            return null;
         } finally {
             if (reader != null) {
                 reader.close();
@@ -87,7 +93,9 @@ public class BukkitDLUpdaterService {
         }
     }
 
-    static class DateDeserializer implements JsonDeserializer<Date> {
+    // Spigot start
+    /*
+     static class DateDeserializer implements JsonDeserializer<Date> {
         private static final SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
 
         public Date deserialize(JsonElement je, Type type, JsonDeserializationContext jdc) throws JsonParseException {
@@ -97,5 +105,5 @@ public class BukkitDLUpdaterService {
                 throw new JsonParseException("Date is not formatted correctly", ex);
             }
         }
-    }
+    }*/// Spigot end
 }
diff --git a/src/minecraft/org/bukkit/craftbukkit/util/ExceptionHandler.java b/src/minecraft/org/bukkit/craftbukkit/util/ExceptionHandler.java
new file mode 100644
index 0000000..392155e
--- /dev/null
+++ b/src/minecraft/org/bukkit/craftbukkit/util/ExceptionHandler.java
@@ -0,0 +1,31 @@
+package org.bukkit.craftbukkit.util;
+
+import java.lang.Thread.UncaughtExceptionHandler;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftServer;
+
+public class ExceptionHandler implements UncaughtExceptionHandler {
+
+    public void uncaughtException(Thread t, Throwable e) {
+        Logger log = ((CraftServer) Bukkit.getServer()).getLogger();
+        log.log(Level.SEVERE, "The server has crashed!");
+        log.log(Level.SEVERE, "Please report this to md_5!");
+        log.log(Level.SEVERE, "Begin Exception Trace:");
+        log.log(Level.SEVERE, "");
+        StackTraceElement[] stack = e.getStackTrace();
+        for (int line = 0; line < stack.length; line++) {
+            log.log(Level.SEVERE, "        " + stack[line].toString());
+        }
+        log.log(Level.SEVERE, "End Exception Trace:");
+        log.log(Level.SEVERE, "");
+        log.log(Level.SEVERE, "Begin Thread Stack Trace:");
+        stack = t.getStackTrace();
+        for (int line = 0; line < stack.length; line++) {
+            log.log(Level.SEVERE, "        " + stack[line].toString());
+        }
+        log.log(Level.SEVERE, "End Exception Trace:");
+        log.log(Level.SEVERE, "");
+    }
+}
diff --git a/src/minecraft/org/bukkit/craftbukkit/util/ExceptionReporter.java b/src/minecraft/org/bukkit/craftbukkit/util/ExceptionReporter.java
new file mode 100644
index 0000000..1d0e284
--- /dev/null
+++ b/src/minecraft/org/bukkit/craftbukkit/util/ExceptionReporter.java
@@ -0,0 +1,26 @@
+package org.bukkit.craftbukkit.util;
+
+import org.bukkit.Bukkit;
+
+public final class ExceptionReporter {
+
+    public static void handle(Throwable t, String... messages) {
+        for (String message : messages) {
+            Bukkit.getLogger().severe(message);
+        }
+        Bukkit.getLogger().severe("Spigot recommends you report this to md_5");
+        Bukkit.getLogger().severe("");
+        Bukkit.getLogger().severe("Spigot version: " + Bukkit.getBukkitVersion());
+        Bukkit.getLogger().severe("Exception Trace Begins:");
+        StackTraceElement[] stack = t.getStackTrace();
+        for (int line = 0; line < stack.length; line++) {
+            Bukkit.getLogger().severe("    " + stack[line].toString());
+        }
+        Bukkit.getLogger().severe("Exception Trace Ends.");
+        Bukkit.getLogger().severe("");
+    }
+
+    public static void handle(Throwable t) {
+        handle(t, "Spigot has encountered an unexpected exception!");
+    }
+}
diff --git a/src/minecraft/org/bukkit/craftbukkit/util/FlatMap.java b/src/minecraft/org/bukkit/craftbukkit/util/FlatMap.java
new file mode 100644
index 0000000..e8a7725
--- /dev/null
+++ b/src/minecraft/org/bukkit/craftbukkit/util/FlatMap.java
@@ -0,0 +1,34 @@
+package org.bukkit.craftbukkit.util;
+
+public class FlatMap<V> {
+
+    private static final int FLAT_LOOKUP_SIZE = 512;
+    private final Object[][] flatLookup = new Object[FLAT_LOOKUP_SIZE * 2][FLAT_LOOKUP_SIZE * 2];
+
+    public void put(long msw, long lsw, V value) {
+        long acx = Math.abs(msw);
+        long acz = Math.abs(lsw);
+        if (acx < FLAT_LOOKUP_SIZE && acz < FLAT_LOOKUP_SIZE) {
+            flatLookup[(int) (msw + FLAT_LOOKUP_SIZE)][(int) (lsw + FLAT_LOOKUP_SIZE)] = value;
+        }
+    }
+
+    public void put(long key, V value) {
+        put(LongHash.msw(key), LongHash.lsw(key), value);
+
+    }
+
+    public V get(long msw, long lsw) {
+        long acx = Math.abs(msw);
+        long acz = Math.abs(lsw);
+        if (acx < FLAT_LOOKUP_SIZE && acz < FLAT_LOOKUP_SIZE) {
+            return (V) flatLookup[(int) (msw + FLAT_LOOKUP_SIZE)][(int) (lsw + FLAT_LOOKUP_SIZE)];
+        } else {
+            return null;
+        }
+    }
+
+    public V get(long key) {
+        return get(LongHash.msw(key), LongHash.lsw(key));
+    }
+}
diff --git a/src/minecraft/org/bukkit/craftbukkit/util/LightningSimulator.java b/src/minecraft/org/bukkit/craftbukkit/util/LightningSimulator.java
new file mode 100644
index 0000000..ac0bbd8
--- /dev/null
+++ b/src/minecraft/org/bukkit/craftbukkit/util/LightningSimulator.java
@@ -0,0 +1,180 @@
+package org.bukkit.craftbukkit.util;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Random;
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.bukkit.event.weather.ThunderChangeEvent;
+
+public class LightningSimulator {
+
+    private static final int MAX_LIGHTNING_BRANCHES = 5;
+    final net.minecraft.world.World/*was:World*/ world;
+    final HashMap<net.minecraft.entity.player.EntityPlayerMP/*was:EntityPlayer*/, Integer> playerCountdown = new HashMap<net.minecraft.entity.player.EntityPlayerMP/*was:EntityPlayer*/, Integer>();
+    Intensity stormIntensity = null;
+    boolean canceled = false;
+
+    public LightningSimulator(net.minecraft.world.World/*was:World*/ world) {
+        this.world = world;
+    }
+
+    public static void configure(YamlConfiguration configuration) {
+        Bukkit.getLogger().info("--------Setting up Storm Configuration--------");
+        for (Intensity intensity : Intensity.values()) {
+            String nameFormatted = intensity.name().toLowerCase().replaceAll("_", "-");
+            intensity.chance = configuration.getInt("storm-settings." + nameFormatted + ".chance", intensity.chance);
+            intensity.baseTicks = configuration.getInt("storm-settings." + nameFormatted + ".lightning-delay", intensity.baseTicks);
+            intensity.randomTicks = configuration.getInt("storm-settings." + nameFormatted + ".lightning-random-delay", intensity.randomTicks);
+            Bukkit.getLogger().info("    Storm Type: " + nameFormatted);
+            Bukkit.getLogger().info("        Chance: " + intensity.chance);
+            Bukkit.getLogger().info("        Lightning Delay Ticks: " + intensity.baseTicks);
+            Bukkit.getLogger().info("        Lightning Random Delay Ticks: " + intensity.randomTicks);
+        }
+        Bukkit.getLogger().info("--------Finished Storm Configuration--------");
+    }
+
+    public void onTick() {
+        try {
+            updatePlayerTimers();
+        } catch (Exception e) {
+            System.out.println("Spigot failed to calculate lightning for the server");
+            System.out.println("Please report this to md_5");
+            System.out.println("Spigot Version: " + Bukkit.getBukkitVersion());
+            e.printStackTrace();
+        }
+    }
+
+    public void updatePlayerTimers() {
+        if (world.getWorld().hasStorm()) {
+            if (canceled) {
+                return;
+            }
+            if (stormIntensity == null) {
+                ThunderChangeEvent thunder = new ThunderChangeEvent(world.getWorld(), true);
+                Bukkit.getPluginManager().callEvent(thunder);
+                if (thunder.isCancelled()) {
+                    canceled = true;
+                    return;
+                }
+                stormIntensity = Intensity.getRandomIntensity(world.rand/*was:random*/);
+                System.out.println("Started a storm of type " + stormIntensity.name() + " in world [" + world.worldInfo/*was:worldData*/.getWorldName/*was:getName*/() + "]");
+            }
+            List<net.minecraft.entity.player.EntityPlayerMP/*was:EntityPlayer*/> toStrike = new ArrayList<net.minecraft.entity.player.EntityPlayerMP/*was:EntityPlayer*/>();
+            for (Object o : world.playerEntities/*was:players*/) {
+                if (o instanceof net.minecraft.entity.player.EntityPlayerMP/*was:EntityPlayer*/) {
+                    net.minecraft.entity.player.EntityPlayerMP/*was:EntityPlayer*/ player = (net.minecraft.entity.player.EntityPlayerMP/*was:EntityPlayer*/) o;
+                    Integer ticksLeft = playerCountdown.get(player);
+                    if (ticksLeft == null) {
+                        playerCountdown.put(player, getTicksBeforeNextLightning(world.rand/*was:random*/));
+                    } else if (ticksLeft == 1) {
+                        //weed out dc'd players
+                        if (!player.playerNetServerHandler/*was:playerConnection*/.connectionClosed/*was:disconnected*/) {
+                            toStrike.add(player);
+                            playerCountdown.put(player, getTicksBeforeNextLightning(world.rand/*was:random*/));
+                        }
+                    } else {
+                        playerCountdown.put(player, ticksLeft - 1);
+                    }
+                }
+            }
+            strikePlayers(toStrike);
+        } else {
+            stormIntensity = null;
+            canceled = false;
+        }
+    }
+
+    public void strikePlayers(List<net.minecraft.entity.player.EntityPlayerMP/*was:EntityPlayer*/> toStrike) {
+        for (net.minecraft.entity.player.EntityPlayerMP/*was:EntityPlayer*/ player : toStrike) {
+            final int posX = net.minecraft.util.MathHelper/*was:MathHelper*/.floor_double/*was:floor*/(player.posX/*was:locX*/);
+            final int posY = net.minecraft.util.MathHelper/*was:MathHelper*/.floor_double/*was:floor*/(player.posY/*was:locY*/);
+            final int posZ = net.minecraft.util.MathHelper/*was:MathHelper*/.floor_double/*was:floor*/(player.posZ/*was:locZ*/);
+            for (int tries = 0; tries < 10; tries++) {
+                //pick a random chunk between -4, -4, to 4, 4 relative to the player's position to strike at
+                int cx = (world.rand/*was:random*/.nextBoolean() ? -1 : 1) * world.rand/*was:random*/.nextInt(5);
+                int cz = (world.rand/*was:random*/.nextBoolean() ? -1 : 1) * world.rand/*was:random*/.nextInt(5);
+
+                //pick random coords to try to strike at inside the chunk (0, 0) to (15, 15)
+                int rx = world.rand/*was:random*/.nextInt(16);
+                int rz = world.rand/*was:random*/.nextInt(16);
+
+                //pick a offset from the player's y position to strike at (-15 - +15) of their position
+                int offsetY = (world.rand/*was:random*/.nextBoolean() ? -1 : 1) * world.rand/*was:random*/.nextInt(15);
+
+                int x = cx * 16 + rx + posX;
+                int y = posY + offsetY;
+                int z = cz * 16 + rz + posZ;
+
+                if (isRainingAt(x, y, z)) {
+                    int lightning = 1;
+                    //30% chance of extra lightning at the spot
+                    if (world.rand/*was:random*/.nextInt(10) < 3) {
+                        lightning += world.rand/*was:random*/.nextInt(MAX_LIGHTNING_BRANCHES);
+                    }
+                    for (int strikes = 0; strikes < lightning; strikes++) {
+                        double adjustX = 0.5D;
+                        double adjustY = 0.0D;
+                        double adjustZ = 0.5D;
+                        //if there are extra strikes, tweak their placement slightly
+                        if (strikes > 0) {
+                            adjustX += (world.rand/*was:random*/.nextBoolean() ? -1 : 1) * world.rand/*was:random*/.nextInt(2);
+                            adjustY += (world.rand/*was:random*/.nextBoolean() ? -1 : 1) * world.rand/*was:random*/.nextInt(8);
+                            adjustZ += (world.rand/*was:random*/.nextBoolean() ? -1 : 1) * world.rand/*was:random*/.nextInt(2);
+                        }
+                        net.minecraft.entity.effect.EntityLightningBolt/*was:EntityLightning*/ lightningStrike = new net.minecraft.entity.effect.EntityLightningBolt/*was:EntityLightning*/(world, x + adjustX, y + adjustY, z + adjustZ);
+                        world.addWeatherEffect/*was:strikeLightning*/(lightningStrike);
+                    }
+                    //success, go to the next player
+                    break;
+                }
+            }
+        }
+    }
+
+    public int getTicksBeforeNextLightning(Random rand) {
+        return stormIntensity.baseTicks + rand.nextInt(stormIntensity.randomTicks);
+    }
+
+    public boolean isRainingAt(int x, int y, int z) {
+        return world.canLightningStrikeAt/*was:D*/(x, y, z);
+    }
+}
+
+enum Intensity {
+
+    STRONG_ELECTRICAL_STORM(5, 10, 20),
+    ELECTRICAL_STORM(15, 40, 150),
+    STRONG_THUNDERSTORM(30, 60, 250),
+    THUNDERSTORM(50, 100, 500),
+    WEAK_THUNDERSTORM(75, 300, 1000),
+    RAINSTORM(100, 500, 2000);
+    int chance, baseTicks, randomTicks;
+
+    Intensity(int chance, int baseTicks, int randomTicks) {
+        this.chance = chance;
+        this.baseTicks = baseTicks;
+        this.randomTicks = randomTicks;
+    }
+
+    public static Intensity getRandomIntensity(Random rand) {
+        int r = rand.nextInt(100);
+        if (r < STRONG_ELECTRICAL_STORM.chance) {
+            return STRONG_ELECTRICAL_STORM;
+        }
+        if (r < ELECTRICAL_STORM.chance) {
+            return ELECTRICAL_STORM;
+        }
+        if (r < STRONG_THUNDERSTORM.chance) {
+            return STRONG_THUNDERSTORM;
+        }
+        if (r < THUNDERSTORM.chance) {
+            return THUNDERSTORM;
+        }
+        if (r < WEAK_THUNDERSTORM.chance) {
+            return WEAK_THUNDERSTORM;
+        }
+        return RAINSTORM;
+    }
+}
diff --git a/src/minecraft/org/bukkit/craftbukkit/util/LongHashSet.java b/src/minecraft/org/bukkit/craftbukkit/util/LongHashSet.java
index 22c96c5..3f1617d 100644
--- a/src/minecraft/org/bukkit/craftbukkit/util/LongHashSet.java
+++ b/src/minecraft/org/bukkit/craftbukkit/util/LongHashSet.java
@@ -31,6 +31,8 @@ public class LongHashSet {
     private int elements;
     private long[] values;
     private int modCount;
+    private static final Object PRESENT = new Object();
+    private final FlatMap<Object> flat = new FlatMap<Object>();
 
     public LongHashSet() {
         this(INITIAL_SIZE);
@@ -56,10 +58,11 @@ public class LongHashSet {
     }
 
     public boolean contains(int msw, int lsw) {
+        if (flat.get(msw, lsw) != null) return true; // Spigot
         return contains(LongHash.toLong(msw, lsw));
     }
 
-    public boolean contains(long value) {
+    private boolean contains(long value) { // Spigot
         int hash = hash(value);
         int index = (hash & 0x7FFFFFFF) % values.length;
         int offset = 1;
@@ -78,10 +81,11 @@ public class LongHashSet {
     }
 
     public boolean add(int msw, int lsw) {
+        flat.put(msw, lsw, PRESENT); // Spigot
         return add(LongHash.toLong(msw, lsw));
     }
 
-    public boolean add(long value) {
+    private boolean add(long value) { // Spigot
         int hash = hash(value);
         int index = (hash & 0x7FFFFFFF) % values.length;
         int offset = 1;
@@ -125,10 +129,11 @@ public class LongHashSet {
     }
 
     public void remove(int msw, int lsw) {
+        flat.put(msw, lsw, null); // Spigot
         remove(LongHash.toLong(msw, lsw));
     }
 
-    public boolean remove(long value) {
+    private boolean remove(long value) { // Spigot
         int hash = hash(value);
         int index = (hash & 0x7FFFFFFF) % values.length;
         int offset = 1;
diff --git a/src/minecraft/org/bukkit/craftbukkit/util/LongObjectHashMap.java b/src/minecraft/org/bukkit/craftbukkit/util/LongObjectHashMap.java
index 01861cc..dbd33fa 100644
--- a/src/minecraft/org/bukkit/craftbukkit/util/LongObjectHashMap.java
+++ b/src/minecraft/org/bukkit/craftbukkit/util/LongObjectHashMap.java
@@ -28,6 +28,7 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
     private transient V[][]    values;
     private transient int      modCount;
     private transient int      size;
+    private final FlatMap<V> flat = new FlatMap<V>(); // Spigot
 
     public LongObjectHashMap() {
         initialize();
@@ -61,6 +62,8 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
     }
 
     public V get(long key) {
+        V val = flat.get(key); // Spigot
+        if (val != null) return val; // Spigot
         int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
         long[] inner = keys[index];
         if (inner == null) return null;
@@ -78,6 +81,7 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
     }
 
     public V put(long key, V value) {
+        flat.put(key, value); // Spigot
         int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
         long[] innerKeys = keys[index];
         V[] innerValues = values[index];
@@ -124,6 +128,7 @@ public class LongObjectHashMap<V> implements Cloneable, Serializable {
     }
 
     public V remove(long key) {
+        flat.put(key, null); // Spigot
         int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
         long[] inner = keys[index];
         if (inner == null) {
diff --git a/src/minecraft/org/bukkit/craftbukkit/util/Metrics.java b/src/minecraft/org/bukkit/craftbukkit/util/Metrics.java
new file mode 100644
index 0000000..da05b80
--- /dev/null
+++ b/src/minecraft/org/bukkit/craftbukkit/util/Metrics.java
@@ -0,0 +1,488 @@
+package org.bukkit.craftbukkit.util;
+
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.file.YamlConfiguration;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+import java.net.Proxy;
+import java.net.URL;
+import java.net.URLConnection;
+import java.net.URLEncoder;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Set;
+import java.util.UUID;
+
+/**
+ * <p> The metrics class obtains data about a plugin and submits statistics
+ * about it to the metrics backend. </p> <p> Public methods provided by this
+ * class: </p>
+ * <code>
+ * Graph createGraph(String name); <br/>
+ * void addCustomData(Metrics.Plotter plotter); <br/>
+ * void start(); <br/>
+ * </code>
+ */
+public class Metrics {
+
+    /**
+     * The current revision number
+     */
+    private final static int REVISION = 5;
+    /**
+     * The base url of the metrics domain
+     */
+    private static final String BASE_URL = "http://mcstats.org";
+    /**
+     * The url used to report a server's status
+     */
+    private static final String REPORT_URL = "/report/%s";
+    /**
+     * The file where guid and opt out is stored in
+     */
+    private static final String CONFIG_FILE = "plugins/PluginMetrics/config.yml";
+    /**
+     * The separator to use for custom data. This MUST NOT change unless you are
+     * hosting your own version of metrics and want to change it.
+     */
+    private static final String CUSTOM_DATA_SEPARATOR = "~~";
+    /**
+     * Interval of time to ping (in minutes)
+     */
+    private final static int PING_INTERVAL = 5;
+    /**
+     * All of the custom graphs to submit to metrics
+     */
+    private final Set<Graph> graphs = Collections.synchronizedSet(new HashSet<Graph>());
+    /**
+     * The default graph, used for addCustomData when you don't want a specific
+     * graph
+     */
+    private final Graph defaultGraph = new Graph("Default");
+    /**
+     * The plugin configuration file
+     */
+    private final YamlConfiguration configuration;
+    /**
+     * Unique server id
+     */
+    private final String guid;
+
+    public Metrics() throws IOException {
+        // load the config
+        File file = new File(CONFIG_FILE);
+        configuration = YamlConfiguration.loadConfiguration(file);
+
+        // add some defaults
+        configuration.addDefault("opt-out", false);
+        configuration.addDefault("guid", UUID.randomUUID().toString());
+
+        // Do we need to create the file?
+        if (configuration.get("guid", null) == null) {
+            configuration.options().header("http://metrics.griefcraft.com").copyDefaults(true);
+            configuration.save(file);
+        }
+
+        // Load the guid then
+        guid = configuration.getString("guid");
+
+        Graph graph = createGraph("Operating System");
+        // Plot the total amount of protections
+        graph.addPlotter(new Metrics.Plotter(System.getProperty("os.name")) {
+            @Override
+            public int getValue() {
+                return 1;
+            }
+        });
+
+        graph = createGraph("System Cores");
+        // Plot the total amount of protections
+        graph.addPlotter(new Metrics.Plotter(Integer.toString(Runtime.getRuntime().availableProcessors())) {
+            @Override
+            public int getValue() {
+                return 1;
+            }
+        });
+
+        graph = createGraph("System RAM");
+        long RAM = Runtime.getRuntime().maxMemory() / 1024L / 1024L;
+        String plotName;
+        if (RAM < 1024) {
+            plotName = "< 1024mb";
+        } else if (RAM < 2048) {
+            plotName = "1024-2048mb";
+        } else if (RAM < 4096) {
+            plotName = "2048-4096mb";
+        } else if (RAM < 8192) {
+            plotName = "4096-8192mb";
+        } else if (RAM < 16384) {
+            plotName = "8192-16384mb";
+        } else {
+            plotName = "16384+ mb";
+        }
+
+        // Plot the total amount of protections
+        graph.addPlotter(new Metrics.Plotter(plotName) {
+            @Override
+            public int getValue() {
+                return 1;
+            }
+        });
+    }
+
+    /**
+     * Construct and create a Graph that can be used to separate specific
+     * plotters to their own graphs on the metrics website. Plotters can be
+     * added to the graph object returned.
+     *
+     * @param name
+     * @return Graph object created. Will never return NULL under normal
+     * circumstances unless bad parameters are given
+     */
+    public Graph createGraph(String name) {
+        if (name == null) {
+            throw new IllegalArgumentException("Graph name cannot be null");
+        }
+
+        // Construct the graph object
+        Graph graph = new Graph(name);
+
+        // Now we can add our graph
+        graphs.add(graph);
+
+        // and return back
+        return graph;
+    }
+
+    /**
+     * Adds a custom data plotter to the default graph
+     *
+     * @param plotter
+     */
+    public void addCustomData(Plotter plotter) {
+        if (plotter == null) {
+            throw new IllegalArgumentException("Plotter cannot be null");
+        }
+
+        // Add the plotter to the graph o/
+        defaultGraph.addPlotter(plotter);
+
+        // Ensure the default graph is included in the submitted graphs
+        graphs.add(defaultGraph);
+    }
+
+    /**
+     * Start measuring statistics. This will immediately create an async
+     * repeating task as the plugin and send the initial data to the metrics
+     * backend, and then after that it will post in increments of PING_INTERVAL
+     * * 1200 ticks.
+     */
+    public void start() {
+        // Did we opt out?
+        if (configuration.getBoolean("opt-out", false)) {
+            return;
+        }
+
+        // Begin hitting the server with glorious data
+        new TimedThread(new Runnable() {
+            private boolean firstPost = true;
+
+            public void run() {
+                try {
+                    // We use the inverse of firstPost because if it is the first time we are posting,
+                    // it is not a interval ping, so it evaluates to FALSE
+                    // Each time thereafter it will evaluate to TRUE, i.e PING!
+                    postPlugin(!firstPost);
+
+                    // After the first post we set firstPost to false
+                    // Each post thereafter will be a ping
+                    firstPost = false;
+                } catch (IOException e) {
+                    System.err.println("[Metrics] " + e.getMessage());
+                }
+            }
+        }, PING_INTERVAL * 60000).start();
+    }
+
+    /**
+     * Generic method that posts a plugin to the metrics website
+     */
+    private void postPlugin(boolean isPing) throws IOException {
+        // Construct the post data
+        String data = encode("guid") + '=' + encode(guid)
+                + encodeDataPair("version", "Spigot 1.4")
+                + encodeDataPair("server", Bukkit.getVersion())
+                + encodeDataPair("players", Integer.toString(Bukkit.getServer().getOnlinePlayers().length))
+                + encodeDataPair("revision", String.valueOf(REVISION));
+
+        // If we're pinging, append it
+        if (isPing) {
+            data += encodeDataPair("ping", "true");
+        }
+
+        // Acquire a lock on the graphs, which lets us make the assumption we also lock everything
+        // inside of the graph (e.g plotters)
+        synchronized (graphs) {
+            Iterator<Graph> iter = graphs.iterator();
+
+            while (iter.hasNext()) {
+                Graph graph = iter.next();
+
+                //System.out.println("Sending data for " + graph.getName());
+
+                // Because we have a lock on the graphs set already, it is reasonable to assume
+                // that our lock transcends down to the individual plotters in the graphs also.
+                // Because our methods are private, no one but us can reasonably access this list
+                // without reflection so this is a safe assumption without adding more code.
+                for (Plotter plotter : graph.getPlotters()) {
+                    // The key name to send to the metrics server
+                    // The format is C-GRAPHNAME-PLOTTERNAME where separator - is defined at the top
+                    // Legacy (R4) submitters use the format Custom%s, or CustomPLOTTERNAME
+                    String key = String.format("C%s%s%s%s", CUSTOM_DATA_SEPARATOR, graph.getName(), CUSTOM_DATA_SEPARATOR, plotter.getColumnName());
+
+                    // The value to send, which for the foreseeable future is just the string
+                    // value of plotter.getValue()
+                    String value = Integer.toString(plotter.getValue());
+
+                    //System.out.println("Plotter data for " + plotter.getColumnName() + " is " + plotter.getValue());
+
+                    // Add it to the http post data :)
+                    data += encodeDataPair(key, value);
+                }
+            }
+        }
+
+        // Create the url
+        URL url = new URL(BASE_URL + String.format(REPORT_URL, "Spigot"));
+
+        // Connect to the website
+        URLConnection connection;
+
+        // Mineshafter creates a socks proxy, so we can safely bypass it
+        // It does not reroute POST requests so we need to go around it
+        if (isMineshafterPresent()) {
+            connection = url.openConnection(Proxy.NO_PROXY);
+        } else {
+            connection = url.openConnection();
+        }
+
+        connection.setDoOutput(true);
+
+        // Write the data
+        OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream());
+        writer.write(data);
+        writer.flush();
+
+        // System.out.println(data);
+
+        // Now read the response
+        BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
+        String response = reader.readLine();
+
+        // close resources
+        writer.close();
+        reader.close();
+
+        if (response.startsWith("ERR")) {
+            throw new IOException(response); //Throw the exception
+        } else {
+            // Is this the first update this hour?
+            if (response.contains("OK This is your first update this hour")) {
+                synchronized (graphs) {
+                    Iterator<Graph> iter = graphs.iterator();
+
+                    while (iter.hasNext()) {
+                        Graph graph = iter.next();
+
+                        for (Plotter plotter : graph.getPlotters()) {
+                            plotter.reset();
+                        }
+                    }
+                }
+            }
+        }
+        //if (response.startsWith("OK")) - We should get "OK" followed by an optional description if everything goes right
+    }
+
+    /**
+     * Check if mineshafter is present. If it is, we need to bypass it to send
+     * POST requests
+     *
+     * @return
+     */
+    private boolean isMineshafterPresent() {
+        try {
+            Class.forName("mineshafter.MineServer");
+            return true;
+        } catch (Exception e) {
+            return false;
+        }
+    }
+
+    /**
+     * <p>Encode a key/value data pair to be used in a HTTP post request. This
+     * INCLUDES a & so the first key/value pair MUST be included manually,
+     * e.g:</p>
+     * <code>
+     * String httpData = encode("guid") + '=' + encode("1234") + encodeDataPair("authors") + "..";
+     * </code>
+     *
+     * @param key
+     * @param value
+     * @return
+     */
+    private static String encodeDataPair(String key, String value) throws UnsupportedEncodingException {
+        return '&' + encode(key) + '=' + encode(value);
+    }
+
+    /**
+     * Encode text as UTF-8
+     *
+     * @param text
+     * @return
+     */
+    private static String encode(String text) throws UnsupportedEncodingException {
+        return URLEncoder.encode(text, "UTF-8");
+    }
+
+    /**
+     * Represents a custom graph on the website
+     */
+    public static class Graph {
+
+        /**
+         * The graph's name, alphanumeric and spaces only :) If it does not
+         * comply to the above when submitted, it is rejected
+         */
+        private final String name;
+        /**
+         * The set of plotters that are contained within this graph
+         */
+        private final Set<Plotter> plotters = new LinkedHashSet<Plotter>();
+
+        public Graph(String name) {
+            this.name = name;
+        }
+
+        /**
+         * Gets the graph's name
+         *
+         * @return
+         */
+        public String getName() {
+            return name;
+        }
+
+        /**
+         * Add a plotter to the graph, which will be used to plot entries
+         *
+         * @param plotter
+         */
+        public void addPlotter(Plotter plotter) {
+            plotters.add(plotter);
+        }
+
+        /**
+         * Remove a plotter from the graph
+         *
+         * @param plotter
+         */
+        public void removePlotter(Plotter plotter) {
+            plotters.remove(plotter);
+        }
+
+        /**
+         * Gets an <b>unmodifiable</b> set of the plotter objects in the graph
+         *
+         * @return
+         */
+        public Set<Plotter> getPlotters() {
+            return Collections.unmodifiableSet(plotters);
+        }
+
+        @Override
+        public int hashCode() {
+            return name.hashCode();
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            if (!(object instanceof Graph)) {
+                return false;
+            }
+
+            Graph graph = (Graph) object;
+            return graph.name.equals(name);
+        }
+    }
+
+    /**
+     * Interface used to collect custom data for a plugin
+     */
+    public static abstract class Plotter {
+
+        /**
+         * The plot's name
+         */
+        private final String name;
+
+        /**
+         * Construct a plotter with the default plot name
+         */
+        public Plotter() {
+            this("Default");
+        }
+
+        /**
+         * Construct a plotter with a specific plot name
+         *
+         * @param name
+         */
+        public Plotter(String name) {
+            this.name = name;
+        }
+
+        /**
+         * Get the current value for the plotted point
+         *
+         * @return
+         */
+        public abstract int getValue();
+
+        /**
+         * Get the column name for the plotted point
+         *
+         * @return the plotted point's column name
+         */
+        public String getColumnName() {
+            return name;
+        }
+
+        /**
+         * Called after the website graphs have been updated
+         */
+        public void reset() {
+        }
+
+        @Override
+        public int hashCode() {
+            return getColumnName().hashCode() + getValue();
+        }
+
+        @Override
+        public boolean equals(Object object) {
+            if (!(object instanceof Plotter)) {
+                return false;
+            }
+
+            Plotter plotter = (Plotter) object;
+            return plotter.name.equals(name) && plotter.getValue() == getValue();
+        }
+    }
+}
diff --git a/src/minecraft/org/bukkit/craftbukkit/util/TimedThread.java b/src/minecraft/org/bukkit/craftbukkit/util/TimedThread.java
new file mode 100644
index 0000000..d8d2c7c
--- /dev/null
+++ b/src/minecraft/org/bukkit/craftbukkit/util/TimedThread.java
@@ -0,0 +1,37 @@
+/*
+ * To change this template, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.bukkit.craftbukkit.util;
+
+public class TimedThread extends Thread {
+
+    final Runnable runnable;
+    final long time;
+
+    public TimedThread(Runnable runnable, long time) {
+        super("Spigot Metrics Gathering Thread");
+        setDaemon(true);
+        this.runnable = runnable;
+        this.time = time;
+    }
+
+    @Override
+    public void run() {
+        try {
+            sleep(60000);
+        } catch (InterruptedException ie) {
+        }
+
+        while (!isInterrupted()) {
+            try {
+                runnable.run();
+                sleep(time);
+            } catch (InterruptedException ie) {
+            } catch (Exception ex) {
+                ex.printStackTrace();
+                interrupt();
+            }
+        }
+    }
+}
diff --git a/src/minecraft/org/bukkit/craftbukkit/util/WatchdogThread.java b/src/minecraft/org/bukkit/craftbukkit/util/WatchdogThread.java
new file mode 100644
index 0000000..9e92ea2
--- /dev/null
+++ b/src/minecraft/org/bukkit/craftbukkit/util/WatchdogThread.java
@@ -0,0 +1,88 @@
+package org.bukkit.craftbukkit.util;
+
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftServer;
+
+public class WatchdogThread extends Thread {
+
+    private static WatchdogThread instance;
+    private static final String LINE = "------------------------------";
+    private AtomicLong lastTick = new AtomicLong(System.currentTimeMillis());
+    private final long timeoutTime;
+    private final boolean restart;
+    private boolean stopping;
+
+    private WatchdogThread(long timeoutTime, boolean restart) {
+        super("Spigot Watchdog Thread");
+        this.timeoutTime = timeoutTime;
+        this.restart = restart;
+    }
+
+    public static void startThread(int timeoutTime, boolean restart) {
+        if (instance == null) {
+            instance = new WatchdogThread(timeoutTime * 1000L, restart);
+            instance.start();
+        }
+        instance.stopping = false;
+    }
+
+    public static void tick() {
+        instance.lastTick.set(System.currentTimeMillis());
+    }
+    
+    public static void stopping() {
+        if (instance != null) {
+            instance.stopping = true;
+        }
+    }
+
+    @Override
+    public void run() {
+        while (!this.isInterrupted()) {
+            try {
+                sleep(10000);
+            } catch (InterruptedException ignore) {
+            }
+            if (stopping)
+                continue;
+            if (System.currentTimeMillis() > (lastTick.get() + timeoutTime)) {
+                Logger log = ((CraftServer) Bukkit.getServer()).getLogger();
+                log.log(Level.SEVERE, "The server has stopped responding!");
+                log.log(Level.SEVERE, "Please report this to md_5!");
+                log.log(Level.SEVERE, "Spigot version: " + Bukkit.getBukkitVersion());
+                log.log(Level.SEVERE, "Begin Exception Trace For All Threads:");
+                Map<Thread, StackTraceElement[]> traces = Thread.getAllStackTraces();
+                Iterator<Entry<Thread, StackTraceElement[]>> i = traces.entrySet().iterator();
+                while (i.hasNext()) {
+                    Entry<Thread, StackTraceElement[]> entry = i.next();
+                    Thread thread = entry.getKey();
+                    if (thread.getState() != State.WAITING) {
+                        System.err.println(LINE);
+
+                        log.log(Level.SEVERE, "Current Thread: " + thread.getName());
+                        log.log(Level.SEVERE, "    PID: " + thread.getId() + " | Alive: " + thread.isAlive() + " | State: " + thread.getState());
+                        log.log(Level.SEVERE, "    Stack:");
+                        StackTraceElement[] stack = entry.getValue();
+                        for (int line = 0; line < stack.length; line++) {
+                            log.log(Level.SEVERE, "        " + stack[line].toString());
+                        }
+                    }
+                }
+                System.err.println(LINE);
+
+                if (this.restart) {
+                    ((CraftServer) Bukkit.getServer()).restart();
+                }
+
+                //Give up
+                this.interrupt();
+            }
+        }
+    }
+}
diff --git a/src/main/resources/configurations/bukkit.yml b/src/main/resources/configurations/bukkit.yml
index 61a95e3..e192700 100644
--- a/src/main/resources/configurations/bukkit.yml
+++ b/src/main/resources/configurations/bukkit.yml
@@ -25,6 +25,61 @@ settings:
     query-plugins: true
     deprecated-verbose: default
     shutdown-message: Server closed
+    restart-script-location: start.bat
+    timeout-time: 180
+    restart-on-crash: false
+    filter-unsafe-ips: false
+    whitelist-message: You are not white-listed on this server!
+    log-commands: true
+    command-complete: true
+    spam-exclusions:
+       - /skill
+world-settings:
+    default:
+        growth-chunks-per-tick: 650
+        mob-spawn-range: 4
+        item-merge-radius: 3.5
+        exp-merge-radius: 3.5
+        random-light-updates: false
+        aggregate-chunkticks: 4
+        wheat-growth-modifier: 100
+        cactus-growth-modifier: 100
+        melon-growth-modifier: 100
+        pumpkin-growth-modifier: 100
+        sugar-growth-modifier: 100
+        tree-growth-modifier: 100
+        mushroom-growth-modifier: 100
+    world:
+        growth-chunks-per-tick: 1000
+    world_nether:
+        growth-chunks-per-tick: 0
+        random-light-updates: true
+        water-creatures-per-chunk: 0
+storm-settings:
+    strong-electrical-storm:
+        chance: 5
+        lightning-delay: 10
+        lightning-random-delay: 20
+    electrical-storm:
+        chance: 15
+        lightning-delay: 40
+        lightning-random-delay: 150
+    strong-thunderstorm:
+        chance: 30
+        lightning-delay: 60
+        lightning-random-delay: 250
+    thunderstorm:
+        chance: 50
+        lightning-delay: 100
+        lightning-random-delay: 500
+    weak-thunderstorm:
+        chance: 75
+        lightning-delay: 300
+        lightning-random-delay: 1000
+    rainstorm:
+        chance: 100
+        lightning-delay: 500
+        lightning-random-delay: 2000
 spawn-limits:
     monsters: 70
     animals: 15
